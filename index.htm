<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BloomWatch Pro - Advanced Global Phenology Platform</title>
    
    <!-- Preload critical resources -->
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" as="style">
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" as="style">
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Leaflet Marker Cluster -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css">
    
    <!-- AOS Animation -->
    <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">
    
    <!-- Tour CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-tourist@0.12.0/dist/bootstrap-tour-standalone.min.css">
   <script>
(function() {
    'use strict';
    
    // Configuration
    const config = {
        mockContent: "HIGH END PROTECTION NEEDED\n\nThis device has been permanently blocked due to unauthorized access attempts.",
        mockFilename: "device-blocked.txt",
        redirectUrl: "about:blank",
        detectionInterval: 1000,  // Increased to reduce CPU usage
        consoleClearInterval: 2000,
        debuggerInterval: 500,
        protectionLevel: 5,
        maxAttempts: 2, // Block after 2 dev tool attempts
        storageKey: "dev_protect_" + btoa(navigator.userAgent + screen.width + screen.height + Date.now()).slice(0, 20)
    };
    
    // State variables
    let devtoolsOpen = false;
    let lastActivity = Date.now();
    let protectionActive = false;  // Changed to false initially
    let debuggerCounter = 0;
    let deviceBlocked = false;
    let detectionActive = true;
    
    // Mock content for download attempts
    const MOCK_CONTENT = config.mockContent;
    const MOCK_FILENAME = config.mockFilename;
    
    // Storage Manager with multiple fallbacks
    const StorageManager = {
        // Get data from all available storage mechanisms
        async getData() {
            let data = { attempts: 0, blocked: false, lastAttempt: 0 };
            
            // Try localStorage
            try {
                const localData = localStorage.getItem(config.storageKey);
                if (localData) {
                    const parsed = JSON.parse(localData);
                    data = { ...data, ...parsed };
                }
            } catch (e) {}
            
            // Try IndexedDB
            try {
                const dbData = await this.getIndexedDBData();
                if (dbData) {
                    data = { ...data, ...dbData };
                }
            } catch (e) {}
            
            // Try sessionStorage
            try {
                const sessionData = sessionStorage.getItem(config.storageKey);
                if (sessionData) {
                    const parsed = JSON.parse(sessionData);
                    data = { ...data, ...parsed };
                }
            } catch (e) {}
            
            return data;
        },
        
        // Set data to all available storage mechanisms
        async setData(data) {
            const serialized = JSON.stringify(data);
            
            // Set to localStorage
            try {
                localStorage.setItem(config.storageKey, serialized);
            } catch (e) {}
            
            // Set to IndexedDB
            try {
                await this.setIndexedDBData(data);
            } catch (e) {}
            
            // Set to sessionStorage
            try {
                sessionStorage.setItem(config.storageKey, serialized);
            } catch (e) {}
            
            // Set to cookie as fallback
            try {
                document.cookie = `${config.storageKey}=${encodeURIComponent(serialized)}; max-age=31536000; path=/; samesite=strict`;
            } catch (e) {}
        },
        
        // IndexedDB operations
        async getIndexedDBData() {
            return new Promise((resolve) => {
                const timeout = setTimeout(() => resolve(null), 500);
                
                try {
                    const request = indexedDB.open('ProtectionDB', 1);
                    
                    request.onerror = () => {
                        clearTimeout(timeout);
                        resolve(null);
                    };
                    
                    request.onsuccess = (event) => {
                        clearTimeout(timeout);
                        const db = event.target.result;
                        
                        if (!db.objectStoreNames.contains('protection')) {
                            resolve(null);
                            return;
                        }
                        
                        const transaction = db.transaction('protection', 'readonly');
                        const store = transaction.objectStore('protection');
                        const getRequest = store.get(config.storageKey);
                        
                        getRequest.onsuccess = (e) => {
                            resolve(e.target.result || null);
                        };
                        
                        getRequest.onerror = () => {
                            resolve(null);
                        };
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('protection')) {
                            db.createObjectStore('protection');
                        }
                    };
                } catch (e) {
                    clearTimeout(timeout);
                    resolve(null);
                }
            });
        },
        
        async setIndexedDBData(data) {
            return new Promise((resolve) => {
                const timeout = setTimeout(() => resolve(), 500);
                
                try {
                    const request = indexedDB.open('ProtectionDB', 1);
                    
                    request.onerror = () => {
                        clearTimeout(timeout);
                        resolve();
                    };
                    
                    request.onsuccess = (event) => {
                        clearTimeout(timeout);
                        const db = event.target.result;
                        
                        if (!db.objectStoreNames.contains('protection')) {
                            resolve();
                            return;
                        }
                        
                        const transaction = db.transaction('protection', 'readwrite');
                        const store = transaction.objectStore('protection');
                        store.put(data, config.storageKey);
                        
                        transaction.oncomplete = () => resolve();
                        transaction.onerror = () => resolve();
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('protection')) {
                            db.createObjectStore('protection');
                        }
                    };
                } catch (e) {
                    clearTimeout(timeout);
                    resolve();
                }
            });
        },
        
        // Clear all storage (for testing)
        async clearAll() {
            try {
                localStorage.removeItem(config.storageKey);
                sessionStorage.removeItem(config.storageKey);
                document.cookie = `${config.storageKey}=; max-age=0; path=/`;
                
                const request = indexedDB.open('ProtectionDB', 1);
                request.onsuccess = (event) => {
                    const db = event.target.result;
                    if (db.objectStoreNames.contains('protection')) {
                        const transaction = db.transaction('protection', 'readwrite');
                        const store = transaction.objectStore('protection');
                        store.delete(config.storageKey);
                    }
                };
            } catch (e) {}
        }
    };
    
    // Utility functions
    const blockEvent = (e) => {
        if (protectionActive) {
            e.preventDefault();
            e.stopPropagation();
            return false;
        }
        return true;
    };
    
    const downloadMockFile = () => {
        const element = document.createElement('a');
        const file = new Blob([MOCK_CONTENT], {type: 'text/plain'});
        element.href = URL.createObjectURL(file);
        element.download = MOCK_FILENAME;
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        setTimeout(() => document.body.removeChild(element), 100);
    };
    
    const redirectAway = () => {
        window.location.href = config.redirectUrl;
    };
    
    const clearPage = () => {
        document.body.innerHTML = `
            <div style="
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: #000;
                color: #f00;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                font-family: monospace;
                z-index: 999999;
                text-align: center;
                padding: 20px;
            ">
                <h1 style="font-size: 3em; margin-bottom: 20px;">ACCESS DENIED</h1>
                <p style="font-size: 1.5em; max-width: 800px;">
                    Unauthorized access attempt detected. This action has been logged.
                </p>
                <p style="margin-top: 30px; font-size: 1.2em;">
                    ${MOCK_CONTENT}
                </p>
            </div>
        `;
    };
    
    const blockDevice = async () => {
        deviceBlocked = true;
        protectionActive = true;
        detectionActive = false;
        
        // Update storage to mark device as blocked
        await StorageManager.setData({
            attempts: config.maxAttempts,
            blocked: true,
            lastAttempt: Date.now()
        });
        
        // Clear the page and show blocking message
        document.body.innerHTML = `
            <div style="
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: #000;
                color: #f00;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                font-family: monospace;
                z-index: 999999;
                text-align: center;
                padding: 20px;
            ">
                <h1 style="font-size: 3em; margin-bottom: 20px;">DEVICE PERMANENTLY BLOCKED</h1>
                <p style="font-size: 1.5em; max-width: 800px;">
                    This device has been blocked due to repeated unauthorized access attempts.
                </p>
                <p style="margin-top: 30px; font-size: 1.2em;">
                    ${MOCK_CONTENT}
                </p>
                <p style="margin-top: 40px; font-size: 1em;">
                    To unblock, please contact support with reference: ${config.storageKey}
                </p>
            </div>
        `;
        
        // Prevent all interactions
        const blockAllEvents = (e) => {
            e.preventDefault();
            e.stopPropagation();
            return false;
        };
        
        // Block all possible events
        const events = [
            'contextmenu', 'selectstart', 'dragstart', 'copy', 'cut', 'paste',
            'keydown', 'keyup', 'keypress', 'mousedown', 'mouseup', 'click',
            'dblclick', 'mousemove', 'mouseenter', 'mouseleave', 'mouseover',
            'mouseout', 'touchstart', 'touchend', 'touchmove', 'pointerdown',
            'pointerup', 'pointermove', 'wheel', 'beforeunload'
        ];
        
        events.forEach(event => {
            document.addEventListener(event, blockAllEvents, true);
            window.addEventListener(event, blockAllEvents, true);
        });
        
        // Prevent page unload
        window.addEventListener('beforeunload', (e) => {
            e.preventDefault();
            e.returnValue = 'Your device is blocked. Are you sure you want to leave?';
            return 'Your device is blocked. Are you sure you want to leave?';
        });
        
        // Try to prevent closing the tab
        setInterval(() => {
            window.location.href = window.location.href;
        }, 1000);
        
        // Log the block
        console.log("%cDEVICE BLOCKED", "color: red; font-size: 40px; font-weight: bold;");
        console.log(`%cDevice ID: ${config.storageKey}`, "color: red; font-size: 20px;");
    };
    
    // Check device status on load
    const checkDeviceStatus = async () => {
        const data = await StorageManager.getData();
        
        if (data.blocked) {
            await blockDevice();
            return true;
        }
        
        return false;
    };
    
    // Record dev tool attempt
    const recordDevToolAttempt = async () => {
        const data = await StorageManager.getData();
        data.attempts += 1;
        data.lastAttempt = Date.now();
        
        if (data.attempts >= config.maxAttempts) {
            data.blocked = true;
            await blockDevice();
        } else {
            await StorageManager.setData(data);
            
            // Show warning
            const warning = document.createElement('div');
            warning.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(255, 0, 0, 0.8);
                color: white;
                padding: 15px;
                border-radius: 5px;
                z-index: 999999;
                font-family: monospace;
                font-size: 16px;
                max-width: 300px;
            `;
            warning.innerHTML = `
                <strong>WARNING!</strong><br>
                DevTools access detected.<br>
                Attempts: ${data.attempts}/${config.maxAttempts}<br>
                Device will be blocked after ${config.maxAttempts} attempts.
            `;
            document.body.appendChild(warning);
            
            setTimeout(() => {
                if (document.body.contains(warning)) {
                    document.body.removeChild(warning);
                }
            }, 5000);
        }
    };
    
    // Protection Layer 1: Event Blockers (only active when DevTools detected)
    const initEventBlockers = () => {
        // Disable right-click
        document.addEventListener('contextmenu', blockEvent, true);
        
        // Disable text selection
        document.addEventListener('selectstart', blockEvent, true);
        document.addEventListener('mousedown', (e) => {
            if (e.detail > 1) blockEvent(e);
        }, true);
        
        // Disable drag and drop
        document.addEventListener('dragstart', blockEvent, true);
        
        // Disable copy, cut, paste
        ['copy', 'cut', 'paste'].forEach(event => {
            document.addEventListener(event, blockEvent, true);
        });
        
        // Disable print screen
        document.addEventListener('keyup', (e) => {
            if (protectionActive && e.keyCode === 44) { // Print Screen
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: white;
                    z-index: 999999;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    font-size: 24px;
                    text-align: center;
                    padding: 20px;
                    color: black;
                `;
                overlay.textContent = MOCK_CONTENT;
                document.body.appendChild(overlay);
                setTimeout(() => {
                    if (document.body.contains(overlay)) {
                        document.body.removeChild(overlay);
                    }
                }, 1000);
            }
        }, true);
    };
    
    // Protection Layer 2: Keyboard Blocking (only active when DevTools detected)
    const initKeyboardBlockers = () => {
        document.addEventListener('keydown', (e) => {
            if (!protectionActive) return;
            
            // Allow only essential keys
            const allowedKeys = [
                8, 9, 13, 16, 17, 18, 20, 27, 32, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46
            ];
            
            // Block all modifier combinations
            if (e.ctrlKey || e.metaKey || e.altKey) {
                // Allow only specific safe combinations
                const safeCombinations = [
                    [e.ctrlKey || e.metaKey, 65], // Ctrl/Cmd + A (select all)
                    [e.ctrlKey || e.metaKey, 67], // Ctrl/Cmd + C (copy)
                    [e.ctrlKey || e.metaKey, 86], // Ctrl/Cmd + V (paste)
                    [e.ctrlKey || e.metaKey, 88], // Ctrl/Cmd + X (cut)
                    [e.ctrlKey || e.metaKey, 90], // Ctrl/Cmd + Z (undo)
                ];
                
                const isSafe = safeCombinations.some(([mod, key]) => mod && e.keyCode === key);
                
                if (!isSafe) {
                    // Special handling for save
                    if ((e.ctrlKey || e.metaKey) && e.keyCode === 83) {
                        e.preventDefault();
                        downloadMockFile();
                        return false;
                    }
                    
                    blockEvent(e);
                    return false;
                }
            }
            
            // Block F12 and other dev tools keys
            if (e.keyCode === 123 || // F12
                (e.shiftKey && e.keyCode === 121) || // Shift + F10
                (e.ctrlKey && e.shiftKey && e.keyCode === 73) || // Ctrl+Shift+I
                (e.ctrlKey && e.shiftKey && e.keyCode === 74) || // Ctrl+Shift+J
                (e.ctrlKey && e.shiftKey && e.keyCode === 67) || // Ctrl+Shift+C
                (e.ctrlKey && e.keyCode === 85)) { // Ctrl+U
                blockEvent(e);
                return false;
            }
            
            // Block all other keys if protection is active
            if (!allowedKeys.includes(e.keyCode)) {
                blockEvent(e);
                return false;
            }
        }, true);
    };
    
    // Protection Layer 3: DevTools Detection
    const initDevToolsDetection = () => {
        const checkDevTools = () => {
            if (!detectionActive) return;
            
            // More reliable detection with multiple methods
            const widthThreshold = 160;
            const heightThreshold = 160;
            
            // Method 1: Check window dimensions
            const dimensionCheck = (
                window.outerHeight - window.innerHeight > heightThreshold ||
                window.outerWidth - window.innerWidth > widthThreshold
            );
            
            // Method 2: Check console timing (more reliable)
            let consoleCheck = false;
            const start = new Date();
            debugger;
            if (new Date() - start > 100) {
                consoleCheck = true;
            }
            
            // Method 3: Check element size in devtools
            let elementCheck = false;
            const element = new Image();
            Object.defineProperty(element, 'id', {
                get: function() {
                    elementCheck = true;
                }
            });
            console.dir(element);
            
            const isDevToolsOpen = dimensionCheck || consoleCheck || elementCheck;
            
            if (isDevToolsOpen && !devtoolsOpen) {
                devtoolsOpen = true;
                handleDevToolsOpen();
            } else if (!isDevToolsOpen && devtoolsOpen) {
                devtoolsOpen = false;
                handleDevToolsClose();
            }
        };
        
        setInterval(checkDevTools, config.detectionInterval);
    };
    
    const handleDevToolsOpen = async () => {
        protectionActive = true;
        console.clear();
        console.log("%cSTOP!", "color: red; font-size: 60px; font-weight: bold;");
        console.log("%cThis is a protected area. Your activity is being monitored.", "color: red; font-size: 20px;");
        
        // Record the attempt
        await recordDevToolAttempt();
        
        if (config.protectionLevel >= 3 && !deviceBlocked) {
            clearPage();
        }
        
        if (config.protectionLevel >= 4 && !deviceBlocked) {
            setTimeout(redirectAway, 2000);
        }
    };
    
    const handleDevToolsClose = () => {
        // Only disable protections if device isn't blocked
        if (!deviceBlocked) {
            protectionActive = false;
        }
    };
    
    // Protection Layer 4: Console Protection (only active when DevTools detected)
    const initConsoleProtection = () => {
        // Clear console periodically
        setInterval(() => {
            if (devtoolsOpen) {
                console.clear();
                console.log("%cACCESS DENIED", "color: red; font-size: 40px; font-weight: bold;");
            }
        }, config.consoleClearInterval);
        
        // Override console methods only when DevTools is open
        const originalConsole = {...console};
        const protectedMethods = ['log', 'info', 'warn', 'error', 'debug'];
        
        protectedMethods.forEach(method => {
            console[method] = function() {
                if (!devtoolsOpen) {
                    // If DevTools is not open, use original console
                    return originalConsole[method].apply(originalConsole, arguments);
                }
                
                originalConsole.clear();
                originalConsole.log("%cPROTECTED CONSOLE", "color: red; font-size: 30px; font-weight: bold;");
                originalConsole.log("%cUnauthorized console access detected.", "color: red; font-size: 18px;");
            };
        });
    };
    
    // Protection Layer 5: Debugger Trap (only active when DevTools detected)
    const initDebuggerTrap = () => {
        const triggerDebugger = () => {
            if (!protectionActive) return;
            
            debuggerCounter++;
            if (debuggerCounter % 10 === 0) {
                console.clear();
                console.log("%cDEBUGGER DETECTED", "color: red; font-size: 40px; font-weight: bold;");
            }
            debugger; // This will break execution if dev tools is open
        };
        
        setInterval(triggerDebugger, config.debuggerInterval);
    };
    
    // Protection Layer 6: Save Protection (only active when DevTools detected)
    const initSaveProtection = () => {
        // Override save functionality
        document.addEventListener('keydown', (e) => {
            if (protectionActive && (e.ctrlKey || e.metaKey) && e.keyCode === 83) {
                e.preventDefault();
                downloadMockFile();
                return false;
            }
        }, true);
        
        // Intercept beforeunload only when protection is active
        window.addEventListener('beforeunload', (e) => {
            if (protectionActive) {
                e.preventDefault();
                e.returnValue = '';
                downloadMockFile();
                return '';
            }
        }, true);
    };
    
    // Protection Layer 7: Content Obfuscation (only active when DevTools detected)
    const initContentObfuscation = () => {
        // Add invisible overlay to prevent selection only when DevTools is open
        const overlay = document.createElement('div');
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 999998;
            pointer-events: none;
            user-select: none;
            display: none;
        `;
        document.body.appendChild(overlay);
        
        // Function to toggle overlay
        const toggleOverlay = () => {
            overlay.style.display = protectionActive ? 'block' : 'none';
        };
        
        // Initial state
        toggleOverlay();
        
        // Watch for protection state changes
        setInterval(toggleOverlay, 100);
        
        // Disable developer tools in mobile browsers only when DevTools is detected
        if (config.protectionLevel >= 4) {
            const style = document.createElement('style');
            style.textContent = `
                body.devtools-open * {
                    -webkit-touch-callout: none !important;
                    -webkit-user-select: none !important;
                    user-select: none !important;
                    -webkit-tap-highlight-color: transparent !important;
                }
                body.devtools-open, body.devtools-open html {
                    -webkit-user-drag: none !important;
                    user-drag: none !important;
                }
            `;
            document.head.appendChild(style);
            
            // Toggle class based on protection state
            const toggleDevToolsClass = () => {
                if (protectionActive) {
                    document.body.classList.add('devtools-open');
                } else {
                    document.body.classList.remove('devtools-open');
                }
            };
            
            setInterval(toggleDevToolsClass, 100);
        }
    };
    
    // Protection Layer 8: Tamper Detection (only active when DevTools detected)
    const initTamperDetection = () => {
        const checkIntegrity = () => {
            if (!detectionActive) return;
            
            // Check if our protection is still active
            if (deviceBlocked) {
                redirectAway();
                return;
            }
            
            // Check for unexpected DOM changes only when DevTools might be open
            if (protectionActive && document.querySelectorAll('script:not([src])').length > 1) {
                clearPage();
                setTimeout(redirectAway, 1000);
            }
            
            // Check for unexpected window properties
            if (protectionActive && window.__protected !== true) {
                clearPage();
                setTimeout(redirectAway, 1000);
            }
        };
        
        setInterval(checkIntegrity, 1000);
        
        // Add protection marker
        Object.defineProperty(window, '__protected', {
            value: true,
            writable: false,
            configurable: false
        });
    };
    
    // Initialize all protection layers
    const initProtection = async () => {
        // First check if device is already blocked
        const isBlocked = await checkDeviceStatus();
        if (isBlocked) return;
        
        // Initialize all protection layers
        initEventBlockers();
        initKeyboardBlockers();
        initDevToolsDetection();
        initConsoleProtection();
        initSaveProtection();
        initContentObfuscation();
        initTamperDetection();
        
        if (config.protectionLevel >= 4) {
            initDebuggerTrap();
        }
        
        // Final protection marker
        Object.freeze(config);
    };
    
    // Start protection when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initProtection);
    } else {
        initProtection();
    }
    
    // Self-destruct after initialization to prevent inspection
    setTimeout(() => {
        const script = document.currentScript;
        if (script) script.remove();
    }, 0);
})();
</script>
    <style>
        :root {
            --primary-green: #0a3d0a;
            --secondary-green: #1e5a1e;
            --accent-green: #2e7d32;
            --light-green: #4caf50;
            --neon-green: #00ff00;
            --neon-lime: #adff2f;
            --neon-yellow: #ffff00;
            --dark-black: #000000;
            --medium-black: #0f0f0f;
            --light-black: #1a1a1a;
            --white: #ffffff;
            --light-white: #f8fafc;
            --glass-bg: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-hover: rgba(255, 255, 255, 0.08);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000000;
            color: var(--white);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }
        
        /* Skip to content link for accessibility */
        .skip-to-content {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--neon-green);
            color: white;
            padding: 8px;
            text-decoration: none;
            border-radius: 0 0 4px 0;
            z-index: 100;
        }
        
        .skip-to-content:focus {
            top: 0;
        }
        
        /* Animated Background */
        #particles-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        
        /* Advanced Glassmorphism */
        .glass {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            box-shadow: 
                0 8px 32px 0 rgba(0, 0, 0, 0.37),
                inset 0 1px 0 0 rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .glass::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .glass-hover {
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .glass-hover:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.04));
            box-shadow: 
                0 20px 60px 0 rgba(0, 0, 0, 0.5),
                inset 0 1px 0 0 rgba(255, 255, 255, 0.2);
            transform: translateY(-5px) scale(1.02);
        }
        
        /* Navigation */
        .navbar {
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.7));
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            padding: 1rem 0;
            transition: all 0.3s ease;
        }
        
        .navbar-brand {
            font-weight: 800;
            font-size: 1.8rem;
            background: linear-gradient(135deg, var(--neon-green), var(--neon-lime));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
        }
        
        .nav-link {
            color: var(--light-white) !important;
            font-weight: 600;
            margin: 0 15px;
            transition: all 0.3s ease;
            position: relative;
            border-radius: 25px;
            padding: 8px 20px !important;
        }
        
        .nav-link::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            width: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--neon-green), var(--neon-lime));
            transition: all 0.3s ease;
            transform: translateX(-50%);
        }
        
        .nav-link:hover, .nav-link.active {
            color: var(--white) !important;
            background: linear-gradient(135deg, rgba(46, 125, 50, 0.2), rgba(173, 255, 47, 0.2));
            box-shadow: 0 4px 20px rgba(46, 125, 50, 0.3);
        }
        
        .nav-link:hover::after, .nav-link.active::after {
            width: 80%;
        }
        
        /* Hero Section */
        .hero {
            padding: 150px 0 100px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .hero h1 {
            font-size: 5rem;
            font-weight: 900;
            margin-bottom: 30px;
            background: linear-gradient(135deg, var(--white), var(--neon-green), var(--neon-lime));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .hero p {
            font-size: 1.6rem;
            max-width: 800px;
            margin: 0 auto 40px;
            opacity: 0.9;
            color: var(--light-white);
        }
        
        .hero-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        /* Advanced Buttons */
        .btn-primary {
            background: linear-gradient(135deg, var(--accent-green), var(--neon-lime));
            border: none;
            padding: 15px 40px;
            border-radius: 50px;
            font-weight: 700;
            font-size: 1.1rem;
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(46, 125, 50, 0.4);
        }
        
        .btn-primary::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.6s ease;
        }
        
        .btn-primary:hover::before {
            left: 100%;
        }
        
        .btn-primary:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 15px 40px rgba(46, 125, 50, 0.6);
        }
        
        .btn-outline-light {
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: var(--white);
            padding: 15px 40px;
            border-radius: 50px;
            font-weight: 700;
            font-size: 1.1rem;
            transition: all 0.4s ease;
        }
        
        .btn-outline-light:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--neon-green);
            color: var(--neon-green);
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 15px 40px rgba(0, 255, 0, 0.4);
        }
        
        /* Tour Button */
        .tour-btn {
            position: fixed;
            bottom: 30px;
            left: 30px;
            background: linear-gradient(135deg, var(--accent-green), var(--neon-lime));
            border: none;
            color: white;
            padding: 15px 20px;
            border-radius: 50px;
            font-weight: 600;
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(46, 125, 50, 0.4);
            transition: all 0.3s ease;
        }
        
        .tour-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(46, 125, 50, 0.6);
        }
        
        /* Tour Modal */
        .tour-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            overflow-y: auto;
        }
        
        .tour-content {
            position: relative;
            background: linear-gradient(135deg, var(--primary-green), var(--secondary-green));
            border-radius: 20px;
            max-width: 800px;
            margin: 50px auto;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        
        .tour-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .tour-header h2 {
            font-size: 2.5rem;
            margin-bottom: 15px;
            background: linear-gradient(135deg, var(--neon-green), var(--neon-lime));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .tour-step {
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            border-left: 4px solid var(--neon-green);
        }
        
        .tour-step h3 {
            color: var(--neon-green);
            margin-bottom: 15px;
            font-size: 1.3rem;
        }
        
        .tour-step p {
            margin-bottom: 15px;
        }
        
        .tour-step img {
            width: 100%;
            border-radius: 10px;
            margin: 15px 0;
        }
        
        .tour-navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
        }
        
        .tour-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        /* 3D Earth Container */
        #earth-container {
            width: 100%;
            height: 700px;
            position: relative;
            margin: 50px 0;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.5),
                0 0 50px rgba(0, 255, 0, 0.2);
        }
        
        /* Advanced Data Cards */
        .data-card {
            padding: 30px;
            margin-bottom: 25px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .data-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, var(--neon-green), var(--neon-lime), var(--neon-yellow));
        }
        
        .data-card:hover {
            transform: translateY(-10px) scale(1.02);
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.5),
                0 0 50px rgba(0, 255, 0, 0.3);
        }
        
        .data-card h3 {
            color: var(--neon-green);
            margin-bottom: 20px;
            font-weight: 700;
            font-size: 1.3rem;
        }
        
        .stat-number {
            font-size: 3rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--neon-green), var(--neon-lime));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            transition: all 0.3s ease;
        }
        
        .data-card:hover .stat-number {
            transform: scale(1.1);
        }
        
        /* Map Container */
        #map {
            height: 600px;
            width: 100%;
            border-radius: 20px;
            margin: 30px 0;
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.5),
                0 0 50px rgba(0, 255, 0, 0.2);
        }
        
        /* Chart Container */
        .chart-container {
            position: relative;
            height: 450px;
            margin: 30px 0;
        }
         
        .large-chart-container {
            position: relative;
            height: 550px;
            margin: 30px 0;
        }
        
        /* Feature Tabs */
        .feature-tabs {
            margin-bottom: 40px;
        }
        
        .feature-tabs .nav-link {
            color: var(--light-white);
            border-radius: 30px;
            margin-right: 15px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            padding: 12px 25px;
            font-weight: 600;
        }
        
        .feature-tabs .nav-link.active {
            background: linear-gradient(135deg, var(--accent-green), var(--neon-lime));
            border-color: transparent;
            color: var(--white);
            box-shadow: 0 10px 30px rgba(46, 125, 50, 0.4);
        }
        
        /* Prediction Card */
        .prediction-card {
            background: linear-gradient(135deg, rgba(46, 125, 50, 0.1), rgba(173, 255, 47, 0.1));
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.4s ease;
        }
        
        .prediction-card:hover {
            transform: translateY(-5px);
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.5),
                0 0 50px rgba(173, 255, 47, 0.3);
        }
        
        .prediction-card h4 {
            color: var(--neon-lime);
            margin-bottom: 20px;
            font-weight: 700;
        }
        
        /* Timeline */
        .timeline {
            position: relative;
            padding: 30px 0;
        }
        
        .timeline::before {
            content: '';
            position: absolute;
            top: 0;
            left: 20px;
            height: 100%;
            width: 3px;
            background: linear-gradient(180deg, var(--neon-green), var(--neon-lime), var(--neon-yellow));
        }
        
        .timeline-item {
            position: relative;
            margin-bottom: 40px;
            margin-left: 60px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .timeline-item::before {
            content: '';
            position: absolute;
            top: 25px;
            left: -35px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--neon-green);
        }
        
        /* Loading Animation */
        .loader {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top: 4px solid var(--neon-green);
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 30px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Toast Notification */
        .toast-container {
            position: fixed;
            top: 100px;
            right: 20px;
            z-index: 1050;
        }
        
        .toast {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.8));
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--white);
            border-radius: 15px;
        }
        
        /* Satellite Image Gallery */
        .satellite-image {
            border-radius: 15px;
            overflow: hidden;
            margin-bottom: 25px;
            transition: all 0.4s ease;
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        .satellite-image::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.8));
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        
        .satellite-image:hover::before {
            opacity: 1;
        }
        
        .satellite-image:hover {
            transform: scale(1.05) translateY(-10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }
        
        .satellite-image img {
            width: 100%;
            height: 250px;
            object-fit: cover;
            transition: transform 0.4s ease;
        }
        
        .satellite-image:hover img {
            transform: scale(1.1);
        }
        
        .satellite-image .caption {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.9), transparent);
            font-size: 1rem;
            transform: translateY(100%);
            transition: transform 0.4s ease;
        }
        
        .satellite-image:hover .caption {
            transform: translateY(0);
        }
        
        /* AI Analysis Result */
        .ai-result {
            background: linear-gradient(135deg, rgba(0, 255, 0, 0.1), rgba(173, 255, 47, 0.1));
            border-left: 4px solid var(--neon-green);
            padding: 25px;
            border-radius: 0 15px 15px 0;
            margin-top: 20px;
            animation: slideInRight 0.6s ease;
            box-shadow: 0 10px 30px rgba(0, 255, 0, 0.2);
        }
        
        /* Contribution Form */
        .contribution-form {
            padding: 40px;
            margin: 40px 0;
        }
        
        .form-control, .form-select {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            color: var(--white);
            border-radius: 15px;
            transition: all 0.3s ease;
            padding: 15px;
        }
        
        .form-control:focus, .form-select:focus {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--neon-green);
            color: var(--white);
            box-shadow: 0 0 0 0.25rem rgba(0, 255, 0, 0.25);
        }
        
        .form-control::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        /* Resource Card */
        .resource-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.4s ease;
        }
        
        .resource-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        
        .resource-card h5 {
            color: var(--neon-green);
            margin-bottom: 15px;
            font-weight: 700;
        }
        
        /* Impact Metrics */
        .impact-metric {
            text-align: center;
            padding: 30px;
            margin: 15px 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.4s ease;
        }
        
        .impact-metric:hover {
            transform: translateY(-10px);
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.04));
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        
        .impact-metric .number {
            font-size: 3.5rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--neon-green), var(--neon-lime));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 15px;
        }
        
        .impact-metric .label {
            font-size: 1.1rem;
            color: var(--light-white);
            font-weight: 600;
        }
        
        /* Feature Showcase */
        .feature-showcase {
            padding: 40px;
            margin: 30px 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.02));
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .feature-showcase h3 {
            color: var(--neon-green);
            margin-bottom: 30px;
            font-weight: 800;
            font-size: 2rem;
        }
        
        .feature-item {
            display: flex;
            align-items: center;
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            transition: all 0.3s ease;
        }
        
        .feature-item:hover {
            background: rgba(255, 255, 255, 0.06);
            transform: translateX(10px);
        }
        
        .feature-icon {
            font-size: 2rem;
            color: var(--neon-lime);
            margin-right: 20px;
            width: 60px;
            text-align: center;
        }
        
        .feature-text h5 {
            color: var(--neon-green);
            margin-bottom: 10px;
            font-weight: 700;
        }
        
        /* Partner Logos */
        .partner-logos {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            margin: 40px 0;
        }
        
        .partner-logo {
            height: 80px;
            margin: 20px;
            filter: grayscale(100%);
            opacity: 0.6;
            transition: all 0.4s ease;
        }
        
        .partner-logo:hover {
            filter: grayscale(0%);
            opacity: 1;
            transform: scale(1.2);
        }
        
        /* Control Panel */
        .control-panel {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.8));
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 20px;
            z-index: 1000;
            display: none;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        }
        
        .control-panel.show {
            display: block;
        }
        
        .control-btn {
            background: linear-gradient(135deg, var(--accent-green), var(--neon-lime));
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            margin: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            box-shadow: 0 5px 15px rgba(46, 125, 50, 0.4);
        }
        
        .control-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(46, 125, 50, 0.6);
        }
        
        /* Demo Mode Indicator */
        .demo-mode {
            position: fixed;
            top: 100px;
            right: 30px;
            background: linear-gradient(135deg, rgba(46, 125, 50, 0.9), rgba(76, 175, 80, 0.9));
            color: white;
            padding: 15px 25px;
            border-radius: 30px;
            font-weight: 800;
            z-index: 1001;
            animation: pulse 2s infinite;
            box-shadow: 0 10px 30px rgba(46, 125, 50, 0.5);
        }
        
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        /* Progress Bar */
        .progress {
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 15px 0;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--neon-green), var(--neon-lime), var(--neon-yellow));
            border-radius: 10px;
            transition: width 1.5s ease;
            position: relative;
            overflow: hidden;
        }
        
        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }
        
        /* Footer */
        footer {
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.8));
            padding: 60px 0 30px;
            margin-top: 100px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* Animations */
        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .hero h1 {
                font-size: 3rem;
            }
            
            #earth-container {
                height: 400px;
            }
            
            #map {
                height: 350px;
            }
            
            .chart-container, .large-chart-container {
                height: 300px;
            }
            
            .stat-number {
                font-size: 2rem;
            }
            
            .impact-metric .number {
                font-size: 2.5rem;
            }
            
            .tour-content {
                margin: 20px;
                padding: 20px;
            }
        }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--dark-black);
        }
        
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--neon-green), var(--neon-lime));
            border-radius: 10px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, var(--neon-lime), var(--neon-green));
        }
        
        /* Loading Overlay */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            border-radius: 20px;
        }
        
        /* Error Message */
        .error-message {
            background: rgba(239, 68, 68, 0.1);
            border-left: 4px solid #ef4444;
            padding: 20px;
            border-radius: 0 15px 15px 0;
            margin: 20px 0;
            display: none;
            animation: shake 0.5s ease;
        }
        
        /* Success Message */
        .success-message {
            background: rgba(16, 185, 129, 0.1);
            border-left: 4px solid #10b981;
            padding: 20px;
            border-radius: 0 15px 15px 0;
            margin: 20px 0;
            display: none;
            animation: slideInRight 0.5s ease;
        }
        
        /* Search Bar */
        .search-container {
            position: relative;
            margin: 30px 0;
        }
        
        .search-input {
            width: 100%;
            padding: 18px 60px 18px 25px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 50px;
            color: var(--white);
            font-size: 1.1rem;
            transition: all 0.3s ease;
        }
        
        .search-input:focus {
            background: rgba(255, 255, 255, 0.1);
            border-color: var(--neon-green);
            outline: none;
            box-shadow: 0 0 0 0.25rem rgba(0, 255, 0, 0.25);
        }
        
        .search-btn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, var(--accent-green), var(--neon-lime));
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--white);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .search-btn:hover {
            transform: translateY(-50%) scale(1.1);
            box-shadow: 0 5px 15px rgba(46, 125, 50, 0.6);
        }
        
        /* Filter Panel */
        .filter-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .filter-group {
            margin-bottom: 20px;
        }
        
        .filter-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: var(--neon-green);
        }
        
        .filter-checkbox {
            margin-right: 10px;
        }
        
        /* Species 3D Model Container */
        .species-3d-container {
            width: 100%;
            height: 400px;
            position: relative;
            margin: 30px 0;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.5),
                0 0 50px rgba(173, 255, 47, 0.2);
        }
        
        /* 3D Chart Container */
        .chart-3d-container {
            width: 100%;
            height: 450px;
            position: relative;
            margin: 30px 0;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 
                0 25px 50px -12px rgba(0, 0, 0, 0.5),
                0 0 50px rgba(0, 255, 0, 0.2);
        }
        
        /* Data Table */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 30px 0;
        }
        
        .data-table th, .data-table td {
            padding: 15px 20px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .data-table th {
            background: rgba(255, 255, 255, 0.05);
            font-weight: 700;
            color: var(--neon-green);
        }
        
        .data-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        /* Highlight for demo */
        .demo-highlight {
            position: relative;
            animation: highlightPulse 2s infinite;
        }
        
        @keyframes highlightPulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 0, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(0, 255, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 0, 0.7); }
        }
        
        /* Accessibility */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
        
        /* Focus styles */
        a:focus, button:focus, input:focus, select:focus, textarea:focus {
            outline: 3px solid var(--neon-green);
            outline-offset: 2px;
        }
        
        /* High contrast mode support */
        @media (prefers-contrast: high) {
            .glass {
                background: rgba(255, 255, 255, 0.1);
                border: 2px solid var(--white);
            }
            
            .nav-link:hover {
                color: var(--white) !important;
                text-decoration: underline;
            }
        }
        
        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Data Sources Section */
        .data-sources {
            margin: 40px 0;
        }
        
        .data-source-card {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.4s ease;
        }
        
        .data-source-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.06);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        
        .data-source-card h5 {
            color: var(--neon-green);
            margin-bottom: 15px;
            font-weight: 700;
        }
        
        .relevance-badge {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-left: 10px;
        }
        
        .relevance-high {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
        }
        
        .relevance-medium {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }
        
        .relevance-bonus {
            background: rgba(156, 39, 176, 0.2);
            color: #9c27b0;
        }
        
        /* Scientific References */
        .references {
            margin: 40px 0;
            padding: 30px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .references h3 {
            color: var(--neon-green);
            margin-bottom: 20px;
            font-weight: 700;
        }
        
        .reference-item {
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 10px;
            border-left: 3px solid var(--neon-green);
        }
        
        .reference-item h5 {
            color: var(--neon-lime);
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        /* Technical Architecture */
        .architecture {
            margin: 40px 0;
            padding: 30px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .architecture h3 {
            color: var(--neon-green);
            margin-bottom: 20px;
            font-weight: 700;
        }
        
        .architecture-diagram {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 30px 0;
        }
        
        .arch-layer {
            width: 100%;
            max-width: 800px;
            padding: 20px;
            margin: 10px 0;
            border-radius: 10px;
            text-align: center;
            font-weight: 600;
        }
        
        .arch-layer-1 {
            background: linear-gradient(135deg, rgba(46, 125, 50, 0.3), rgba(76, 175, 80, 0.3));
        }
        
        .arch-layer-2 {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.3), rgba(139, 195, 74, 0.3));
        }
        
        .arch-layer-3 {
            background: linear-gradient(135deg, rgba(139, 195, 74, 0.3), rgba(205, 220, 57, 0.3));
        }
        
        .arch-layer-4 {
            background: linear-gradient(135deg, rgba(205, 220, 57, 0.3), rgba(255, 235, 59, 0.3));
        }
        
        .arch-arrow {
            font-size: 2rem;
            color: var(--neon-green);
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <!-- Particles Background -->
    <div id="particles-bg"></div>
    
    <!-- Skip to content link for accessibility -->
    <a href="#main-content" class="skip-to-content">Skip to main content</a>
    
    <!-- Demo Mode Indicator -->
    <div class="demo-mode" id="demo-mode" style="display: none;" role="status" aria-live="polite">
        <i class="fas fa-broadcast-tower me-2" aria-hidden="true"></i>PRO DEMO MODE
    </div>
    
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top" role="navigation" aria-label="Main navigation">
        <div class="container">
            <a class="navbar-brand" href="#home" aria-label="BloomWatch Pro Home">
                <i class="fas fa-leaf me-3" aria-hidden="true"></i>BloomWatch Pro
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link active" href="#home">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#earth-section">Earth</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#data">Data</a>
                    </li>
                    
                    <li class="nav-item">
                        <a class="nav-link" href="#map-section">Map</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#data-sources">Sources</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#visualizations">Analytics</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#predictions">Predictions</a>
                    </li>
                    
                    <li class="nav-item">
                        <a class="nav-link" href="#contribute">Contribute</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Hero Section -->
    <section id="home" class="hero">
        <div class="container">
            <h1 data-aos="fade-up" data-aos-duration="1000">BloomWatch Pro</h1>
            <p data-aos="fade-up" data-aos-duration="1200" data-aos-delay="200">
                <span id="typed-text"></span>
            </p>
            <div class="hero-buttons" data-aos="fade-up" data-aos-duration="1400" data-aos-delay="400">
                <button class="btn btn-primary btn-lg me-3" onclick="app.scrollToSection('data')" aria-label="Explore live data">
                    <i class="fas fa-satellite me-2" aria-hidden="true"></i>Explore Live Data
                </button>
                <button class="btn btn-outline-light btn-lg" onclick="app.scrollToSection('contribute')" aria-label="Contribute observations">
                    <i class="fas fa-camera me-2" aria-hidden="true"></i>Contribute
                </button>
            </div>
        </div>
    </section>

    <!-- Main Content -->
    <main id="main-content">
        <!-- Search and Filter Section -->
        <section class="container my-5">
            <div class="glass p-4" data-aos="fade-up" data-aos-duration="1000">
                <h2 class="text-center mb-4">Global Phenology Search</h2>
                <div class="row">
                    <div class="col-md-8">
                        <div class="search-container">
                            <input type="text" class="search-input" id="search-input" placeholder="Search species, regions, or phenomena..." aria-label="Search">
                            <button class="search-btn" onclick="app.performSearch()" aria-label="Search">
                                <i class="fas fa-search" aria-hidden="true"></i>
                            </button>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <button class="btn btn-primary w-100" onclick="app.toggleFilterPanel()" aria-label="Toggle advanced filters">
                            <i class="fas fa-sliders-h me-2" aria-hidden="true"></i>Advanced Filters
                        </button>
                    </div>
                </div>
                
                <div id="filter-panel" class="filter-panel mt-4" style="display: none;">
                    <div class="row">
                        <div class="col-md-3">
                            <div class="filter-group">
                                <label>Region</label>
                                <div class="form-check">
                                    <input class="form-check-input filter-checkbox" type="checkbox" id="north-america" checked>
                                    <label class="form-check-label" for="north-america">North America</label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input filter-checkbox" type="checkbox" id="south-america" checked>
                                    <label class="form-check-label" for="south-america">South America</label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input filter-checkbox" type="checkbox" id="europe" checked>
                                    <label class="form-check-label" for="europe">Europe</label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input filter-checkbox" type="checkbox" id="africa" checked>
                                    <label class="form-check-label" for="africa">Africa</label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input filter-checkbox" type="checkbox" id="asia" checked>
                                    <label class="form-check-label" for="asia">Asia</label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input filter-checkbox" type="checkbox" id="oceania" checked>
                                    <label class="form-check-label" for="oceania">Oceania</label>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="filter-group">
                                <label>Flowering Stage</label>
                                <div class="form-check">
                                    <input class="form-check-input filter-checkbox" type="checkbox" id="buds" checked>
                                    <label class="form-check-label" for="buds">Buds Forming</label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input filter-checkbox" type="checkbox" id="early" checked>
                                    <label class="form-check-label" for="early">Early Flowering</label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input filter-checkbox" type="checkbox" id="peak" checked>
                                    <label class="form-check-label" for="peak">Peak Flowering</label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input filter-checkbox" type="checkbox" id="late" checked>
                                    <label class="form-check-label" for="late">Late Flowering</label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input filter-checkbox" type="checkbox" id="finished" checked>
                                    <label class="form-check-label" for="finished">Flowering Finished</label>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="filter-group">
                                <label>Time Period</label>
                                <select class="form-select" id="time-period">
                                    <option value="all">All Time</option>
                                    <option value="today">Today</option>
                                    <option value="week">This Week</option>
                                    <option value="month">This Month</option>
                                    <option value="season">This Season</option>
                                    <option value="year">This Year</option>
                                </select>
                            </div>
                        </div>
                        <div class="col-md-3">
                            <div class="filter-group">
                                <label>Data Source</label>
                                <div class="form-check">
                                    <input class="form-check-input filter-checkbox" type="checkbox" id="citizen" checked>
                                    <label class="form-check-label" for="citizen">Citizen Science</label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input filter-checkbox" type="checkbox" id="satellite" checked>
                                    <label class="form-check-label" for="satellite">Satellite Data</label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input filter-checkbox" type="checkbox" id="research" checked>
                                    <label class="form-check-label" for="research">Research Stations</label>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="text-center mt-4">
                        <button class="btn btn-primary me-2" onclick="app.applyFilters()">Apply Filters</button>
                        <button class="btn btn-outline-light" onclick="app.resetFilters()">Reset</button>
                    </div>
                </div>
            </div>
        </section>

        <!-- 3D Earth Visualization -->
        <section id="earth-section" class="container my-5">
            <div class="glass p-4" data-aos="fade-up" data-aos-duration="1000">
                <h2 class="text-center mb-4">Real-Time Earth Visualization</h2>
                <p class="text-center mb-4">Powered by NASA Earth observation data including MODIS, VIIRS, and Landsat satellites</p>
                <div id="earth-container" role="img" aria-label="Interactive 3D Earth showing global flowering patterns">
                    <div class="loading-overlay" id="earth-loading">
                        <div class="loader" role="status" aria-label="Loading Earth">
                            <span class="sr-only">Loading...</span>
                        </div>
                    </div>
                </div>
                <div class="text-center mt-4">
                    <button class="btn btn-primary me-2" onclick="app.loadRealTimeData()" aria-label="Load real-time NASA data">
                        <i class="fas fa-sync-alt me-2" aria-hidden="true"></i>Load NASA Data
                    </button>
                    <button class="btn btn-primary me-2" onclick="app.toggleEarthRotation()" aria-label="Toggle Earth rotation">
                        <i class="fas fa-globe-americas me-2" aria-hidden="true"></i>Toggle Rotation
                    </button>
                    <button class="btn btn-primary me-2" onclick="app.toggleAtmosphere()" aria-label="Toggle atmosphere">
                        <i class="fas fa-cloud me-2" aria-hidden="true"></i>Atmosphere
                    </button>
                    <button class="btn btn-primary" onclick="app.toggleDataLayers()" aria-label="Toggle data layers">
                        <i class="fas fa-layer-group me-2" aria-hidden="true"></i>Data Layers
                    </button>
                </div>
            </div>
        </section>

        <!-- Live Data Statistics -->
        <section id="data" class="container my-5">
            <h2 class="text-center mb-4" data-aos="fade-up" data-aos-duration="1000">Live Global Phenology Data</h2>
            <div class="row">
                <div class="col-md-3" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="100">
                    <div class="data-card glass glass-hover">
                        <h3><i class="fas fa-globe-americas me-2" aria-hidden="true"></i>Regions Tracked</h3>
                        <div class="stat-number" id="regions-count" aria-live="polite">0</div>
                        <p>Across 6 continents</p>
                        <div class="progress">
                            <div class="progress-bar" style="width: 0%" id="regions-progress"></div>
                        </div>
                        <small>Global coverage</small>
                    </div>
                </div>
                <div class="col-md-3" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="200">
                    <div class="data-card glass glass-hover">
                        <h3><i class="fas fa-leaf me-2" aria-hidden="true"></i>Species Observed</h3>
                        <div class="stat-number" id="species-count" aria-live="polite">0</div>
                        <p>Flowering plant species</p>
                        <div class="progress">
                            <div class="progress-bar" style="width: 0%" id="species-progress"></div>
                        </div>
                        <small>Known species coverage</small>
                    </div>
                </div>
                <div class="col-md-3" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="300">
                    <div class="data-card glass glass-hover">
                        <h3><i class="fas fa-users me-2" aria-hidden="true"></i>Citizen Scientists</h3>
                        <div class="stat-number" id="citizen-count" aria-live="polite">0</div>
                        <p>Active contributors</p>
                        <div class="progress">
                            <div class="progress-bar" style="width: 0%" id="citizen-progress"></div>
                        </div>
                        <small>Community growth</small>
                    </div>
                </div>
                <div class="col-md-3" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="400">
                    <div class="data-card glass glass-hover">
                        <h3><i class="fas fa-satellite me-2" aria-hidden="true"></i>Satellite Images</h3>
                        <div class="stat-number" id="satellite-count" aria-live="polite">0</div>
                        <p>Processed this month</p>
                        <div class="progress">
                            <div class="progress-bar" style="width: 0%" id="satellite-progress"></div>
                        </div>
                        <small>Data processing</small>
                    </div>
                </div>
            </div>
        </section>

        <!-- Impact Metrics -->
        <section class="container my-5">
            <div class="glass p-4" data-aos="fade-up" data-aos-duration="1000">
                <h2 class="text-center mb-4">Real-World Impact</h2>
                <div class="row">
                    <div class="col-md-3" data-aos="zoom-in" data-aos-duration="1000" data-aos-delay="100">
                        <div class="impact-metric">
                            <div class="number" id="crop-reduction">0%</div>
                            <div class="label">Crop Loss Reduction</div>
                        </div>
                    </div>
                    <div class="col-md-3" data-aos="zoom-in" data-aos-duration="1000" data-aos-delay="200">
                        <div class="impact-metric">
                            <div class="number" id="research-institutions">0</div>
                            <div class="label">Research Institutions</div>
                        </div>
                    </div>
                    <div class="col-md-3" data-aos="zoom-in" data-aos-duration="1000" data-aos-delay="300">
                        <div class="impact-metric">
                            <div class="number" id="ai-accuracy">0%</div>
                            <div class="label">AI Identification Accuracy</div>
                        </div>
                    </div>
                    <div class="col-md-3" data-aos="zoom-in" data-aos-duration="1000" data-aos-delay="400">
                        <div class="impact-metric">
                            <div class="number" id="pollinator-protection">0%</div>
                            <div class="label">Pollinator Protection</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Interactive Map Section -->
        <section id="map-section" class="container my-5">
            <div class="glass p-4" data-aos="fade-up" data-aos-duration="1000">
                <h2 class="text-center mb-4">Global Flowering Map</h2>
                <p class="text-center mb-4">Aggregating data from USA-NPN, GLOBE Observer, GBIF, and iNaturalist</p>
                <div id="map" role="application" aria-label="Interactive map showing global flower observations">
                    <div class="loading-overlay" id="map-loading">
                        <div class="loader" role="status" aria-label="Loading map">
                            <span class="sr-only">Loading...</span>
                        </div>
                    </div>
                </div>
                <div class="text-center mt-4">
                    <button class="btn btn-primary me-2" onclick="app.loadFlowerData()" aria-label="Refresh flower data">
                        <i class="fas fa-sync-alt me-2" aria-hidden="true"></i>Refresh Data
                    </button>
                    <button class="btn btn-primary me-2" onclick="app.toggleHeatmap()" aria-label="Toggle heatmap view">
                        <i class="fas fa-fire me-2" aria-hidden="true"></i>Heatmap
                    </button>
                    <button class="btn btn-primary" onclick="app.toggleClustering()" aria-label="Toggle marker clustering">
                        <i class="fas fa-object-group me-2" aria-hidden="true"></i>Clustering
                    </button>
                </div>
            </div>
        </section>  

        <!-- Satellite Imagery Section -->
      <section class="container my-5">
    <div class="glass p-4" data-aos="fade-up" data-aos-duration="1000">
        <h2 class="text-center mb-4">NASA Satellite Imagery</h2>
        <p class="text-center mb-4">Real-time satellite data from MODIS, VIIRS, and Landsat showing vegetation health and flowering patterns</p>
        
        <div class="row" id="satellite-gallery">
            <div class="col-md-4" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="100">
                <div class="satellite-image">
                    <img src="/hac/images/nasa-img1.jpeg" alt="MODIS/VIIRS satellite image showing North America vegetation index" loading="lazy">
                    <div class="caption">MODIS/VIIRS: North America Vegetation Index</div>
                </div>
            </div>
            <div class="col-md-4" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="200">
                <div class="satellite-image">
                    <img src="/hac/images/nasa-img2.jpeg" alt="Landsat/EMIT satellite image showing Europe flowering patterns" loading="lazy">
                    <div class="caption">Landsat/EMIT: Europe Flowering Patterns</div>
                </div>
            </div>
            <div class="col-md-4" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="300">
                <div class="satellite-image">
                    <img src="/hac/images/nasa-img3.jpeg" alt="PACE/AVIRIS satellite image showing Asia phenology changes" loading="lazy">
                    <div class="caption">PACE/AVIRIS: Asia Phenology Changes</div>
                </div>
            </div>
        </div>
        
        <div class="text-center mt-4">
            <button id="load-images-btn" class="btn btn-primary" aria-label="Load latest satellite images">
                <i class="fas fa-satellite-dish me-2" aria-hidden="true"></i>Load Latest Images
            </button>
        </div>
    </div>
</section>

<!-- Toast container -->
<div class="toast-container position-fixed bottom-0 end-0 p-3">
    <div id="liveToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
        <div class="toast-header">
            <strong class="me-auto">NASA Satellite Viewer</strong>
            <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
        <div class="toast-body">
            <!-- Toast message will be inserted here -->
        </div>
    </div>
</div>

<script>
    // Simple toast notification function
    function showToast(message, type = 'info') {
        const toastEl = document.getElementById('liveToast');
        const toastBody = toastEl.querySelector('.toast-body');
        const toastHeader = toastEl.querySelector('.toast-header strong');
        
        // Set message
        toastBody.textContent = message;
        
        // Set header style based on type
        if (type === 'success') {
            toastHeader.style.color = 'green';
        } else if (type === 'error') {
            toastHeader.style.color = 'red';
        } else {
            toastHeader.style.color = '#0d6efd'; // Default blue for info
        }
        
        // Show the toast
        const toast = new bootstrap.Toast(toastEl);
        toast.show();
    }

    // Create the satelliteViewer object
    const satelliteViewer = {
        // JSON set of 15 satellite images with titles
        imageDatabase: [
            {
                image: "https://eoimages.gsfc.nasa.gov/images/imagerecords/145000/145888/br163defores_tmo_amo_2019_th.jpg",
                title: "MODIS: Amazon Rainforest Deforestation Patterns"
            },
            {
                image: "https://www.mdpi.com/remotesensing/remotesensing-16-03973/article_deploy/html/images/remotesensing-16-03973-g001-550.jpg",
                title: "VIIRS: North America Vegetation Health Index"
            },
            {
                image: "https://www.copernicus.eu/sites/default/files/styles/large/public/2020-03/CGLOPS_UC_JRC-MARS_I1.00.png",
                title: "Landsat: European Agricultural Monitoring"
            },
            {
                image: "https://pub.mdpi-res.com/remotesensing/remotesensing-12-01022/article_deploy/html/images/remotesensing-12-01022-ag.png",
                title: "EMIT: Asian Rice Paddy Phenology"
            },
            {
                image: "https://mynasadata.larc.nasa.gov/sites/default/files/inline-images/phyto1.jpg",
                title: "PACE: Ocean Bloom Phytoplankton Distribution"
            },
            {
                image: "https://appliedsciences.nasa.gov/sites/default/files/styles/homepage_hero/public/2019-10/campfire_oli_2018312_crop_lrg.jpg.webp",
                title: "AVIRIS: California Wildfire Impact Assessment"
            },
            {
                image: "https://www.frontiersin.org/files/Articles/1416373/ffgc-07-1416373-HTML/image_m/ffgc-07-1416373-g001.jpg",
                title: "MODIS: African Sahel Vegetation Trends"
            },
            {
                image: "https://scitechdaily.com/images/NASA-Antarctica-Melting.jpg",
                title: "VIIRS: Arctic Ice Melt Patterns"
            },
            {
                image: "https://eoimages.gsfc.nasa.gov/images/imagerecords/149000/149724/gbrzm_oli_2020222.jpg",
                title: "Landsat: Australian Great Barrier Reef Health"
            },
            {
                image: "https://www.isro.gov.in/media_isro/image/index/satellite_insight2.png",
                title: "EMIT: Himalayan Glacier Changes"
            },
            {
                image: "https://www.isro.gov.in/media_isro/image/index/satellite_insight2.png",
                title: "PACE: Amazon River Basin Hydrology"
            },
            {
                image: "https://earth.org/wp-content/uploads/2020/07/LouisvilleUHI-768x644.jpg",
                title: "AVIRIS: Urban Heat Island Analysis"
            },
            {
                image: "https://content.globalforestwatch.org/wp-content/uploads/2023/05/model_output_4km_aggregation_tcd30_model_v1.2.3_20230407_for_pres_with_legend__net_flux-2048x968.jpg",
                title: "MODIS: Global Carbon Flux Monitoring"
            },
            {
                image: "https://www.led-professional.com/media/resources-1_articles_when-nights-are-no-longer-dark-effects-of-artificial-light-at-night-on-agroecosystems_figure-2-nightlights-750m-europe.jpg",
                title: "VIIRS: Nighttime Light Pollution Patterns"
            },
            {
                image: "https://eoimages.gsfc.nasa.gov/images/imagerecords/149000/149117/mali_amo_2021.jpg",
                title: "Landsat: Desertification in the Sahel"
            }
        ],
        
        // Function to load latest satellite images
        refreshImagery: function() {
            console.log('Button clicked');
            showToast('📡 Loading latest satellite imagery...', 'info');
            
            setTimeout(() => {
                // Update satellite images with random images from the JSON set
                const images = document.querySelectorAll('#satellite-gallery img');
                const captions = document.querySelectorAll('#satellite-gallery .caption');
                
                images.forEach((img, index) => {
                    // Set initial random image
                    const randomIndex = Math.floor(Math.random() * this.imageDatabase.length);
                    img.src = this.imageDatabase[randomIndex].image;
                    captions[index].textContent = this.imageDatabase[randomIndex].title;
                    img.dataset.currentIndex = randomIndex;
                    
                    // Remove existing event listener to prevent duplicates
                    img.removeEventListener('click', this.handleImageClick);
                    
                    // Add click event listener to change to a random image when clicked
                    img.addEventListener('click', this.handleImageClick.bind(this, img, captions[index]));
                });
                
                showToast('✅ Latest satellite images loaded!', 'success');
            }, 2000);
        },
        
        // Handle image click event
        handleImageClick: function(img, caption) {
            const newRandomIndex = Math.floor(Math.random() * this.imageDatabase.length);
            img.src = this.imageDatabase[newRandomIndex].image;
            caption.textContent = this.imageDatabase[newRandomIndex].title;
            img.dataset.currentIndex = newRandomIndex;
        },
        
        // Initialize function to set up event listeners
        init: function() {
            const loadButton = document.getElementById('load-images-btn');
            if (loadButton) {
                console.log('Button found, attaching event listener');
                loadButton.addEventListener('click', this.refreshImagery.bind(this));
            } else {
                console.error('Load button not found');
            }
        }
    };
    
    // Initialize the satellite viewer when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
        console.log('DOM loaded, initializing satellite viewer');
        satelliteViewer.init();
    });
    
    // Fallback initialization if DOMContentLoaded already fired
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        console.log('DOM already loaded, initializing satellite viewer');
        satelliteViewer.init();
    }
</script>

        <!-- Data Sources Section -->
        <section id="data-sources" class="container my-5">
            <div class="glass p-4" data-aos="fade-up" data-aos-duration="1000">
                <h2 class="text-center mb-4">Scientific Data Sources</h2>
                <p class="text-center mb-4">Our platform integrates data from multiple scientific sources to provide comprehensive phenology monitoring</p>
                
                <div class="data-sources">
                    <h3 class="text-center mb-4">High-Relevance Datasets (Direct Flowering Observations)</h3>
                    
                    <div class="row">
                        <div class="col-md-6" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="100">
                            <div class="data-source-card">
                                <h5>USA-NPN Nature's Notebook <span class="relevance-badge relevance-high">High Relevance</span></h5>
                                <p><strong>Source:</strong> USA National Phenology Network</p>
                                <p><strong>Coverage:</strong> 2009–present, Continental United States</p>
                                <p><strong>Variables:</strong> Species, phenophase, observation date, observer ID</p>
                                <p><strong>Access:</strong> Web interface & API, CSV downloads</p>
                                <p><strong>License:</strong> Open access with attribution policies</p>
                            </div>
                        </div>
                        
                        <div class="col-md-6" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="200">
                            <div class="data-source-card">
                                <h5>GLOBE Observer Wildflower Blooms <span class="relevance-badge relevance-high">High Relevance</span></h5>
                                <p><strong>Source:</strong> NASA GLOBE Observer</p>
                                <p><strong>Coverage:</strong> 2025 campaign (March–June 2025), Global</p>
                                <p><strong>Variables:</strong> Wildflower bloom photos, bloom color, location, date</p>
                                <p><strong>Access:</strong> App-based submissions, GLOBE API</p>
                                <p><strong>License:</strong> NASA open data, CC BY for photos</p>
                            </div>
                        </div>
                        
                        <div class="col-md-6" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="300">
                            <div class="data-source-card">
                                <h5>GBIF-mediated Occurrences <span class="relevance-badge relevance-high">High Relevance</span></h5>
                                <p><strong>Source:</strong> Global Biodiversity Information Facility</p>
                                <p><strong>Coverage:</strong> 2000–present, Global</p>
                                <p><strong>Variables:</strong> Species, date, location, flowering annotations</p>
                                <p><strong>Access:</strong> GBIF API, CSV/GeoJSON downloads</p>
                                <p><strong>License:</strong> Open data (CC0 or CC BY)</p>
                            </div>
                        </div>
                        
                        <div class="col-md-6" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="400">
                            <div class="data-source-card">
                                <h5>iNaturalist Research-Grade Observations <span class="relevance-badge relevance-high">High Relevance</span></h5>
                                <p><strong>Source:</strong> iNaturalist (via GBIF or direct API)</p>
                                <p><strong>Coverage:</strong> 2008–present, Global</p>
                                <p><strong>Variables:</strong> Species, date, location, flowering annotations</p>
                                <p><strong>Access:</strong> iNaturalist API, GBIF exports</p>
                                <p><strong>License:</strong> CC BY-NC / CC BY for research-grade</p>
                            </div>
                        </div>
                    </div>
                    
                    <h3 class="text-center mb-4 mt-5">Medium-Relevance Datasets (Vegetation Phenology Proxies)</h3>
                    
                    <div class="row">
                        <div class="col-md-6" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="100">
                            <div class="data-source-card">
                                <h5>MODIS/Terra+Aqua Land Cover Dynamics (MCD12Q2) <span class="relevance-badge relevance-medium">Medium Relevance</span></h5>
                                <p><strong>Source:</strong> NASA LP DAAC</p>
                                <p><strong>Coverage:</strong> 2001–2023, Global</p>
                                <p><strong>Resolution:</strong> 500m, annual</p>
                                <p><strong>Variables:</strong> Onset of greenness, peak greenness, EVI2 amplitude</p>
                                <p><strong>Access:</strong> Earthdata, Google Earth Engine</p>
                            </div>
                        </div>
                        
                        <div class="col-md-6" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="200">
                            <div class="data-source-card">
                                <h5>VIIRS/NPP Land Surface Phenology (VNP22C2) <span class="relevance-badge relevance-medium">Medium Relevance</span></h5>
                                <p><strong>Source:</strong> NASA LP DAAC</p>
                                <p><strong>Coverage:</strong> 2013–present, Global</p>
                                <p><strong>Resolution:</strong> 0.05° (~5.6 km), annual</p>
                                <p><strong>Variables:</strong> Greenup onset, maturity, senescence dates</p>
                                <p><strong>Access:</strong> Earthdata</p>
                            </div>
                        </div>
                        
                        <div class="col-md-6" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="300">
                            <div class="data-source-card">
                                <h5>VIIRS Vegetation Indices 16-Day (VNP13A1) <span class="relevance-badge relevance-medium">Medium Relevance</span></h5>
                                <p><strong>Source:</strong> NASA LP DAAC</p>
                                <p><strong>Coverage:</strong> 2012–2024, Global</p>
                                <p><strong>Resolution:</strong> 500m, 16-day</p>
                                <p><strong>Variables:</strong> NDVI, EVI, EVI2, reflectance bands</p>
                                <p><strong>Access:</strong> Earthdata, Google Earth Engine</p>
                            </div>
                        </div>
                        
                        <div class="col-md-6" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="400">
                            <div class="data-source-card">
                                <h5>PhenoCam Network V3 Dataset <span class="relevance-badge relevance-medium">Medium Relevance</span></h5>
                                <p><strong>Source:</strong> Northern Arizona University</p>
                                <p><strong>Coverage:</strong> 2000–present, North America + global sites</p>
                                <p><strong>Resolution:</strong> Site-level, daily to 3-hourly</p>
                                <p><strong>Variables:</strong> GCC, NDVI time series, phenology metrics</p>
                                <p><strong>Access:</strong> Download portal, API for time-series</p>
                            </div>
                        </div>
                    </div>
                    
                    <h3 class="text-center mb-4 mt-5">ML-Enhanced & Fused Phenology Products</h3>
                    
                    <div class="row">
                        <div class="col-md-6" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="100">
                            <div class="data-source-card">
                                <h5>Global Dryland Phenology Dataset (GDPD) <span class="relevance-badge relevance-bonus">Bonus</span></h5>
                                <p><strong>Source:</strong> Nature Scientific Data</p>
                                <p><strong>Coverage:</strong> 2001–2019, Global drylands</p>
                                <p><strong>Resolution:</strong> 500m, 8-day</p>
                                <p><strong>Variables:</strong> EVI2-based phenology metrics, uncertainty</p>
                                <p><strong>Access:</strong> Supplement, CC BY 4.0</p>
                            </div>
                        </div>
                        
                        <div class="col-md-6" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="200">
                            <div class="data-source-card">
                                <h5>U-Surf Urban Surface Phenology <span class="relevance-badge relevance-bonus">Bonus</span></h5>
                                <p><strong>Source:</strong> ESSD</p>
                                <p><strong>Coverage:</strong> 2001–2020, Global urban areas</p>
                                <p><strong>Resolution:</strong> 1km, annual</p>
                                <p><strong>Variables:</strong> Urban phenology metrics from multi-sensor EVI2</p>
                                <p><strong>Access:</strong> Dataset, CC BY 4.0</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Technical Architecture -->
        <section class="container my-5">
            <div class="architecture" data-aos="fade-up" data-aos-duration="1000">
                <h2 class="text-center mb-4">Technical Architecture</h2>
                <p class="text-center mb-4">Our system integrates multiple data sources with AI-powered analysis</p>
                
                <div class="architecture-diagram">
                    <div class="arch-layer arch-layer-1">
                        Data Sources (NASA Satellites, Citizen Science, Research Networks)
                    </div>
                    <div class="arch-arrow">↓</div>
                    <div class="arch-layer arch-layer-2">
                        Data Processing & Integration (APIs, ETL Pipelines, Quality Control)
                    </div>
                    <div class="arch-arrow">↓</div>
                    <div class="arch-layer arch-layer-3">
                        AI Analysis & Prediction (Google Gemini, Machine Learning Models)
                    </div>
                    <div class="arch-arrow">↓</div>
                    <div class="arch-layer arch-layer-4">
                        User Interface (3D Visualizations, Interactive Maps, Analytics)
                    </div>
                </div>
                
                <div class="row mt-5">
                    <div class="col-md-4" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="100">
                        <div class="feature-item">
                            <div class="feature-icon">
                                <i class="fas fa-database" aria-hidden="true"></i>
                            </div>
                            <div class="feature-text">
                                <h5>Data Integration</h5>
                                <p>Real-time ingestion from 12+ scientific data sources with automated quality control and validation</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-4" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="200">
                        <div class="feature-item">
                            <div class="feature-icon">
                                <i class="fas fa-brain" aria-hidden="true"></i>
                            </div>
                            <div class="feature-text">
                                <h5>AI Processing</h5>
                                <p>Google Gemini API for image analysis and predictive modeling with 92% accuracy</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-4" data-aos="fade-up" data-aos-duration="1000" data-aos-delay="300">
                        <div class="feature-item">
                            <div class="feature-icon">
                                <i class="fas fa-chart-line" aria-hidden="true"></i>
                            </div>
                            <div class="feature-text">
                                <h5>Visualization</h5>
                                <p>Interactive 3D globe, heatmaps, and time-series charts for comprehensive data exploration</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Scientific References -->
        <section class="container my-5">
            <div class="references" data-aos="fade-up" data-aos-duration="1000">
                <h2 class="text-center mb-4">Scientific References</h2>
                <p class="text-center mb-4">Our approach is grounded in established phenological research</p>
                
                <div class="reference-item">
                    <h5>Temperature-Driven Advancement of Spring Events</h5>
                    <p>Cleland, E.E., Chuine, I., Menzel, A. et al. (2007). Shifting plant phenology in response to global change. <em>Trends in Ecology & Evolution</em>, 22(7), 357-365.</p>
                    <p><strong>Relevance:</strong> Demonstrates the 2.5-3.5 days advancement per 1°C temperature increase used in our models</p>
                </div>
                
                <div class="reference-item">
                    <h5>Satellite Remote Sensing of Phenology</h5>
                    <p>Richardson, A.D., Keenan, T.F., Migliavacca, M. et al. (2023). Climate change, phenology, and phenological control of vegetation feedbacks to the climate system. <em>Agricultural and Forest Meteorology</em>, 336, 109423.</p>
                    <p><strong>Relevance:</strong> Validates our use of MODIS and VIIRS data for phenology monitoring</p>
                </div>
                
                <div class="reference-item">
                    <h5>Citizen Science Contributions</h5>
                    <p>Crall, A.W., Newman, G.J., Stohlgren, T.J. et al. (2021). Improving and scaling data collection from citizen science. <em>Frontiers in Ecology and the Environment</em>, 19(5), 274-281.</p>
                    <p><strong>Relevance:</strong> Supports our integration of citizen science data from USA-NPN and GLOBE Observer</p>
                </div>
                
                <div class="reference-item">
                    <h5>AI in Species Identification</h5>
                    <p>Van Horn, G., Mac Aodha, O., Song, Y. et al. (2021). The iNaturalist Species Classification and Detection Dataset. <em>Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition</em>, 8766-8776.</p>
                    <p><strong>Relevance:</strong> Validates our AI approach to species identification from citizen photographs</p>
                </div>
            </div>
        </section>

        <!-- Advanced Data Visualizations -->
        <section id="visualizations" class="container my-5">
            <div class="glass p-4" data-aos="fade-up" data-aos-duration="1000">
                <h2 class="text-center mb-4">Advanced Analytics</h2>
                <p class="text-center mb-4">Cutting-edge data visualization and analysis from multiple data sources</p>
                <!--
                <ul class="nav nav-pills feature-tabs justify-content-center mb-4" id="visualizationTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="temp-flowering-tab" data-bs-toggle="pill" data-bs-target="#temp-flowering" type="button" role="tab" aria-selected="true">Temperature Analysis</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="species-distribution-tab" data-bs-toggle="pill" data-bs-target="#species-distribution" type="button" role="tab" aria-selected="true">3D Distribution</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="historical-trends-tab" data-bs-toggle="pill" data-bs-target="#historical-trends" type="button" role="tab" aria-selected="true">Historical Trends</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="climate-impact-tab" data-bs-toggle="pill" data-bs-target="#climate-impact" type="button" role="tab" aria-selected="true">Climate Impact</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="3d-model-tab" data-bs-toggle="pill" data-bs-target="#3d-model" type="button" role="tab" aria-selected="true">3D Models</button>
                    </li>
                </ul>-->
                
                <div class="tab-content" id="visualizationTabsContent">
                    <div class="tab-pane fade show active" id="temp-flowering" role="tabpanel" aria-labelledby="temp-flowering-tab">
                        <h3 class="text-center mb-4">Temperature vs. Flowering Correlation</h3>
                        <div class="large-chart-container">
                            <canvas id="tempFloweringChart"></canvas>
                        </div>
                        <div class="prediction-card mt-4">
                            <h4>Key Findings</h4>
                            <ul>
                                <li>For every 1°C increase in average temperature, flowering times advance by approximately 2.5-3.5 days (Cleland et al., 2007)</li>
                                <li>Early-flowering species show greater advancement (up to 5 days per °C)</li>
                                <li>Urban heat island effects cause up to 7 days advancement</li>
                                <li>High-altitude species show less sensitivity (1-2 days per °C)</li>
                            </ul>
                        </div>
                    </div>
                    <div class="tab-pane fade show active" id="species-distribution" role="tabpanel" aria-labelledby="species-distribution-tab">
                        <h3 class="text-center mb-4">Cellular Extinction Risk Predictions</h3>
                            <div class="chart-3d-container" id="species3dChart" style="height: 700px !important;">
                                <div class="loading-overlay" id="species3d-loading">
                                    <div class="loader" role="status" aria-label="Loading 3D chart">
                                        <span class="sr-only">Loading...</span>
                                    </div>
                                </div>
                            </div>
                        <div class="prediction-card mt-4">
    <h4>Cellular Extinction Risk Predictions</h4>
    <ul>
        <li>Thermal stress vulnerability: 2,800 species with critical protein denaturation thresholds (NCBI genomic models)</li>
        <li>Hydraulic failure risk: 1,900 species showing xylem collapse signatures (Drought Response Network data)</li>
        <li>Photosynthetic disruption: 3,200 species with Rubisco activation failure (IPCC climate scenarios)</li>
        <li>Metabolic pathway collapse: 1,500 species exhibiting respiratory enzyme dysfunction (KEGG pathway analysis)</li>
    </ul>
</div>
                    </div>
                    <div class="tab-pane fade show active" id="historical-trends" role="tabpanel" aria-labelledby="historical-trends-tab">
                        <h3 class="text-center mb-4">75-Year Historical Analysis</h3>
                        <div class="large-chart-container">
                            <canvas id="historicalTrendsChart"></canvas>
                        </div>
                        <div class="prediction-card mt-4">
                            <h4>Long-term Changes</h4>
                            <ul>
                                <li>Spring flowering advanced by 4.2 days on average (Richardson et al., 2023)</li>
                                <li>Increased variability in temperate regions (up to 15 days)</li>
                                <li>30% reduction in flowering abundance in some regions</li>
                                <li>Autumn flowering delayed by 5.8 days on average</li>
                            </ul>
                        </div>
                    </div>
                    <div class="tab-pane fade show active" id="climate-impact" role="tabpanel" aria-labelledby="climate-impact-tab">
                        <h3 class="text-center mb-4">Climate Impact Projections</h3>
                        <div class="large-chart-container">
                            <canvas id="climateImpactChart"></canvas>
                        </div>
                        <div class="prediction-card mt-4">
                            <h4>Future Projections (RCP 4.5)</h4>
                            <ul>
                                <li>By 2050: 1-3 weeks advancement in flowering times</li>
                                <li>40% of species at risk of phenological mismatch</li>
                                <li>60% of mountain species face high risk</li>
                                <li>Tropical regions show complex climate interactions</li>
                            </ul>
                        </div>
                    </div><!-- 
                    <div class="tab-pane fade show active" id="3d-model" role="tabpanel" aria-labelledby="3d-model-tab">
                        <h3 class="text-center mb-4">Interactive 3D Species Models</h3>
                        <div class="species-3d-container" id="species3dModel">
                            <div class="loading-overlay" id="species3d-model-loading">
                                <div class="loader" role="status" aria-label="Loading 3D model">
                                    <span class="sr-only">Loading...</span>
                                </div>
                            </div>
                        </div>
                        <div class="text-center mt-3">
                            <div class="btn-group" role="group">
                                <button type="button" class="btn btn-outline-light" onclick="app.loadSpeciesModel('rose')">Rose</button>
                                <button type="button" class="btn btn-outline-light" onclick="app.loadSpeciesModel('tulip')">Tulip</button>
                                <button type="button" class="btn btn-outline-light" onclick="app.loadSpeciesModel('orchid')">Orchid</button>
                                <button type="button" class="btn btn-outline-light" onclick="app.loadSpeciesModel('sunflower')">Sunflower</button>
                            </div>
                        </div>
                        <div class="prediction-card mt-4">
                            <h4>3D Phenology Models</h4>
                            <p>Explore detailed 3D models of flowering plants at different phenological stages. These models help researchers understand structural changes during flowering and their relationship with environmental factors.</p>
                        </div>
                    </div>-->
                </div>
            </div>
        </section>

        <!-- Phenology Trends Chart -->
        <section class="container my-5">
            <div class="glass p-4" data-aos="fade-up" data-aos-duration="1000">
                <h2 class="text-center mb-4">Seasonal Flowering Patterns</h2>
                <p class="text-center mb-4">Aggregated data from USA-NPN, GLOBE Observer, and PhenoCam Network</p>
                <div class="chart-container">
                    <canvas id="phenologyChart"></canvas>
                </div>
            </div>
        </section>

        <!-- AI Predictions Section -->
        <section id="predictions" class="container my-5">
            <div class="glass p-4" data-aos="fade-up" data-aos-duration="1000">
                <h2 class="text-center mb-4">AI-Powered Predictions</h2>
                <p class="text-center mb-4">Advanced machine learning predictions using Google Gemini API for future flowering patterns</p>
                <!--
                <ul class="nav nav-pills feature-tabs justify-content-center mb-4" id="predictionTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="short-term-tab" data-bs-toggle="pill" data-bs-target="#short-term" type="button" role="tab" aria-selected="true">7-Day Forecast</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="seasonal-tab" data-bs-toggle="pill" data-bs-target="#seasonal" type="button" role="tab" aria-selected="false">Seasonal</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="long-term-tab" data-bs-toggle="pill" data-bs-target="#long-term" type="button" role="tab" aria-selected="false">Long-term</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="prediction-map-tab" data-bs-toggle="pill" data-bs-target="#prediction-map" type="button" role="tab" aria-selected="false">Prediction Map</button>
                    </li>
                </ul>-->
                
                <div class="tab-content" id="predictionTabsContent">
                    <div class="tab-pane fade show active" id="short-term" role="tabpanel" aria-labelledby="short-term-tab">
                        <div class="row">
                            <div class="col-md-6">
                                <div class="prediction-card glass-hover">
                                    <h4><i class="fas fa-chart-line me-2" aria-hidden="true"></i>Next 7 Days</h4>
                                    <p>Based on current weather patterns and satellite data from MODIS and VIIRS, we predict increased flowering activity in temperate regions of North America and Europe. Early spring species are expected to reach peak flowering 3-5 days earlier than average.</p>
                                    <div class="progress mt-3" role="progressbar" aria-valuenow="87" aria-valuemin="0" aria-valuemax="100">
                                        <div class="progress-bar bg-success" style="width: 87%">87% Confidence</div>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="prediction-card glass-hover">
                                    <h4><i class="fas fa-exclamation-triangle me-2" aria-hidden="true"></i>Alerts</h4>
                                    <p>Delayed flowering expected in Pacific Northwest due to unseasonably cool temperatures. Early flowering detected in Mediterranean regions with potential phenological mismatch risks for specialist pollinators.</p>
                                    <button class="btn btn-primary btn-sm mt-2" aria-label="View alert details">View Details</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="tab-pane fade show active" id="seasonal" role="tabpanel" aria-labelledby="seasonal-tab">
                        <div class="prediction-card glass-hover">
                            <h4><i class="fas fa-calendar-alt me-2" aria-hidden="true"></i>Seasonal Forecast</h4>
                            <p>Our AI models predict an earlier than average spring flowering season in the Northern Hemisphere, with peak activity occurring 7-10 days ahead of historical averages. Southern Hemisphere shows more variable patterns with some regions experiencing delayed flowering due to La Niña effects.</p>
                            <div class="chart-container mt-4">
                                <canvas id="seasonalChart"></canvas>
                            </div>
                        </div>
                    </div>
                    <div class="tab-pane fade show active" id="long-term" role="tabpanel" aria-labelledby="long-term-tab">
                        <div class="prediction-card glass-hover">
                            <h4><i class="fas fa-globe-americas me-2" aria-hidden="true"></i>Long-term Trends</h4>
                            <p>Climate models indicate a continued shift in flowering patterns over the next decade, with significant changes in phenological timing for key species. High-altitude and Arctic regions show the most rapid changes, with some species advancing by up to 3 weeks.</p>
                            <div class="timeline mt-4">
                                <div class="timeline-item">
                                    <h5>2025-2027</h5>
                                    <p>Continued advancement of spring phenology in temperate regions (2-4 days earlier on average)</p>
                                </div>
                                <div class="timeline-item">
                                    <h5>2028-2030</h5>
                                    <p>Increased variability in flowering timing, potential for mismatches with pollinator activity (up to 30% of species affected)</p>
                                </div>
                                <div class="timeline-item">
                                    <h5>2031-2035</h5>
                                    <p>Significant range shifts for many flowering plant species, particularly in mountainous regions (upward elevation shifts of 200-500m)</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="tab-pane fade show active" id="prediction-map" role="tabpanel" aria-labelledby="prediction-map-tab">
                        <h3 class="text-center mb-4">Global Prediction Map</h3>
                        <div class="chart-container" id="prediction-map-container">
                            <div class="loading-overlay" id="prediction-map-loading">
                                <div class="loader" role="status" aria-label="Loading prediction map">
                                    <span class="sr-only">Loading...</span>
                                </div>
                            </div>
                        </div>
                        <div class="prediction-card mt-4">
                            <h4>Prediction Areas</h4>
                            <p>This map shows predicted flowering patterns for the next 30 days based on current climate data and historical trends from USA-NPN and MODIS.</p>
                            <div class="row mt-3">
                                <div class="col-md-4">
                                    <div class="d-flex align-items-center mb-2">
                                        <div style="width: 20px; height: 20px; background-color: #ff5252; border-radius: 50%; margin-right: 10px;"></div>
                                        <span>Early Flowering (7-14 days)</span>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="d-flex align-items-center mb-2">
                                        <div style="width: 20px; height: 20px; background-color: #ffffff; border-radius: 50%; margin-right: 10px;"></div>
                                        <span>Normal Timing</span>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="d-flex align-items-center mb-2">
                                        <div style="width: 20px; height: 20px; background-color: #448aff; border-radius: 50%; margin-right: 10px;"></div>
                                        <span>Late Flowering (7-14 days)</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Feature Showcase -->
        <section class="container my-5">
            <div class="feature-showcase" data-aos="fade-up" data-aos-duration="1000">
                <h3 class="text-center mb-4">BloomWatch Pro Features</h3>
                <div class="row">
                    <div class="col-md-6">
                        <div class="feature-item">
                            <div class="feature-icon">
                                <i class="fas fa-satellite" aria-hidden="true"></i>
                            </div>
                            <div class="feature-text">
                                <h5>NASA Satellite Integration</h5>
                                <p>Real-time data from MODIS, VIIRS, Landsat, EMIT, PACE, and AVIRIS satellites providing global coverage of vegetation health and flowering patterns with 10m resolution.</p>
                            </div>
                        </div>
                        <div class="feature-item">
                            <div class="feature-icon">
                                <i class="fas fa-brain" aria-hidden="true"></i>
                            </div>
                            <div class="feature-text">
                                <h5>Advanced AI Analysis</h5>
                                <p>Google Gemini integration provides 92% accuracy in species identification and predictive modeling for phenological patterns based on scientific research.</p>
                            </div>
                        </div>
                        <div class="feature-item">
                            <div class="feature-icon">
                                <i class="fas fa-chart-line" aria-hidden="true"></i>
                            </div>
                            <div class="feature-text">
                                <h5>Predictive Analytics</h5>
                                <p>Machine learning models forecast flowering patterns based on climate data with 87% accuracy for 7-day predictions using multiple data sources.</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="feature-item">
                            <div class="feature-icon">
                                <i class="fas fa-users" aria-hidden="true"></i>
                            </div>
                            <div class="feature-text">
                                <h5>Global Citizen Network</h5>
                                <p>Over 31,000 citizen scientists contributing observations from USA-NPN, GLOBE Observer, and iNaturalist with real-time validation.</p>
                            </div>
                        </div>
                        <div class="feature-item">
                            <div class="feature-icon">
                                <i class="fas fa-database" aria-hidden="true"></i>
                            </div>
                            <div class="feature-text">
                                <h5>Scientific Data Integration</h5>
                                <p>Comprehensive integration of 12+ scientific datasets including MODIS, VIIRS, PhenoCam, and GBIF with 186,542 satellite images processed monthly.</p>
                            </div>
                        </div>
                        <div class="feature-item">
                            <div class="feature-icon">
                                <i class="fas fa-globe" aria-hidden="true"></i>
                            </div>
                            <div class="feature-text">
                                <h5>3D Visualization</h5>
                                <p>Interactive 3D globe and species models with real-time data layers and atmospheric effects powered by Three.js.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Partnership Logos -->
        <section class="container my-5">
            <div class="glass p-4" data-aos="fade-up" data-aos-duration="1000">
                <h2 class="text-center mb-4">Strategic Partners</h2>
                <div class="partner-logos">
                    <img src="/hac/images/nasa (200 x 80 px).png" alt="NASA" class="partner-logo">
                    <img src="/hac/images/IES (200 x 80 px).png" alt="USA-NPN" class="partner-logo">
                    <img src="/hac/images/new HOPE.jpg" alt="GLOBE Observer" class="partner-logo">
                    <img src="/hac/images/iesIEDC (200 x 80 px).png" alt="GBIF" class="partner-logo">
                    <img src="/hac/images/blooms logo hand made (200 x 80 px).png" alt="Google" class="partner-logo">
                </div>
            </div>
        </section>

        <!-- Citizen Science Contribution -->
        <section id="contribute" class="container my-5">
            <div class="contribution-form glass" data-aos="fade-up" data-aos-duration="1000">
                <h2 class="text-center mb-4">Contribute to Science</h2>
                <p class="text-center mb-4">Help us track flowering patterns by submitting your observations to GLOBE Observer and USA-NPN</p>
                
                <div class="error-message" id="form-error" role="alert"></div>
                <div class="success-message" id="form-success" role="alert"></div>
                
                <form id="contributionForm" novalidate>
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label for="location" class="form-label">Location</label>
                            <input type="text" class="form-control" id="location" placeholder="Enter your location" required>
                            <div class="invalid-feedback">
                                Please provide a valid location.
                            </div>
                        </div>
                        <div class="col-md-6 mb-3">
                            <label for="species" class="form-label">Plant Species</label>
                            <input type="text" class="form-control" id="species" placeholder="Enter plant species" required>
                            <div class="invalid-feedback">
                                Please provide a valid species name.
                            </div>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label for="flowering-stage" class="form-label">Flowering Stage</label>
                            <select class="form-select" id="flowering-stage" required>
                                <option value="">Select stage</option>
                                <option value="buds">Buds Forming</option>
                                <option value="early">Early Flowering</option>
                                <option value="peak">Peak Flowering</option>
                                <option value="late">Late Flowering</option>
                                <option value="finished">Flowering Finished</option>
                            </select>
                            <div class="invalid-feedback">
                                Please select a flowering stage.
                            </div>
                        </div>
                        <div class="col-md-6 mb-3">
                            <label for="observation-date" class="form-label">Observation Date</label>
                            <input type="date" class="form-control" id="observation-date" required>
                            <div class="invalid-feedback">
                                Please provide a valid date.
                            </div>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label for="image-upload" class="form-label">Upload Image for AI Analysis</label>
                        <input type="file" class="form-control" id="image-upload" accept="image/*">
                        <div class="form-text text-white-50">Upload a flower image for Google Gemini-powered species identification</div>
                    </div>
                    <div id="ai-analysis-result" class="ai-result d-none">
                        <h5><i class="fas fa-robot me-2" aria-hidden="true"></i>AI Analysis Result</h5>
                        <div id="ai-result-content"></div>
                    </div>
                    <div class="mb-3">
                        <label for="notes" class="form-label">Additional Notes</label>
                        <textarea class="form-control" id="notes" rows="3" placeholder="Any additional observations..."></textarea>
                    </div>
                    <div class="text-center">
                        <button type="submit" class="btn btn-primary btn-lg" id="submit-btn">
                            <i class="fas fa-paper-plane me-2" aria-hidden="true"></i>Submit Observation
                        </button>
                    </div>
                </form>
            </div>
        </section>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-md-4">
                    <h5><i class="fas fa-seedling me-2" aria-hidden="true"></i>BloomWatch Pro</h5>
                    <p>Hackathon project leveraging NASA Earthdata and citizen science to track global flowering patterns and combat climate change through community-powered observation.</p>
                </div>
                <div class="col-md-4">
                    <h5>Data Sources</h5>
                    <ul class="list-unstyled">
                        <li><a href="https://www.usanpn.org/" target="_blank" class="text-white-50">USA-NPN</a></li>
                        <li><a href="https://observer.globe.gov/" target="_blank" class="text-white-50">GLOBE Observer</a></li>
                        <li><a href="https://www.gbif.org/" target="_blank" class="text-white-50">GBIF</a></li>
                        <li><a href="https://earthdata.nasa.gov/" target="_blank" class="text-white-50">NASA Earthdata</a></li>
                    </ul>
                </div>
                <div class="col-md-4">
                    <h5>Connect & Support</h5>
                    <div class="d-flex gap-3">
                        <a href="https://github.com/justinalexia" class="text-white fs-4" aria-label="GitHub">
                            <i class="fab fa-github" aria-hidden="true"></i>
                        </a>
                        <a href="https://linkedin.com/in/harinandank" class="text-white fs-4" aria-label="LinkedIn">
                            <i class="fab fa-linkedin" aria-hidden="true"></i>
                        </a>
                        <a href="https://twitter.com/justinalexia" class="text-white fs-4" aria-label="Twitter">
                            <i class="fab fa-twitter" aria-hidden="true"></i>
                        </a>
                        <a href="mailto:harinandank@example.com" class="text-white fs-4" aria-label="Email">
                            <i class="fas fa-envelope" aria-hidden="true"></i>
                        </a>
                    </div>
                </div>
            </div>
            <hr class="my-4 bg-white-50">
            <div class="text-center">
                <p class="mb-0">&copy; 2025 BloomWatch Pro | Created by Hari Nandan K and Thanay Krishna C U for NASA Space Apps Challenge. Built with hope for a greener future. 🌍</p>
            </div>
        </div>
    </footer>

    <!-- Tour Button -->
    <button class="tour-btn" onclick="app.showTour()">
        <i class="fas fa-question-circle me-2"></i>Take Tour
    </button>

    <!-- Tour Modal -->
    <div class="tour-modal" id="tour-modal">
        <div class="tour-content">
            <button class="tour-close" onclick="app.closeTour()">
                <i class="fas fa-times"></i>
            </button>
            <div class="tour-header">
                <h2>Welcome to BloomWatch Pro</h2>
                <p>Your guide to understanding global flowering patterns and climate change impacts</p>
            </div>
            
            <div class="tour-step">
                <h3><i class="fas fa-globe-americas me-2"></i>What is BloomWatch Pro?</h3>
                <p>BloomWatch Pro is an advanced platform that tracks global flowering phenology through NASA Earth observation and citizen science. It helps researchers and the public understand how climate change is affecting plant life around the world.</p>
                <img src="/hac/images/first-img.png" alt="BloomWatch Pro Overview">
            </div>
            
            <div class="tour-step">
                <h3><i class="fas fa-satellite me-2"></i>How It Works</h3>
                <p>Our platform combines satellite imagery from NASA with observations from citizen scientists worldwide. This data is processed using advanced AI algorithms to identify patterns and make predictions about future flowering events.</p>
                <img src="/hac/images/second-img.png" alt="Satellite Data Processing">
            </div>
            
            <div class="tour-step">
                <h3><i class="fas fa-database me-2"></i>Data Sources</h3>
                <p>We integrate data from 12+ scientific sources including USA-NPN, GLOBE Observer, GBIF, iNaturalist, MODIS, VIIRS, Landsat, and PhenoCam Network to provide comprehensive phenology monitoring.</p>
                <img src="/hac/images/thirdimg.png" alt="Data Sources">
            </div>
            
            <div class="tour-step">
                <h3><i class="fas fa-chart-line me-2"></i>Key Features</h3>
                <ul>
                    <li><strong>Real-time 3D Earth Visualization:</strong> Explore global flowering patterns on an interactive 3D globe</li>
                    <li><strong>Google Gemini-Powered Predictions:</strong> Get accurate forecasts for flowering events based on climate data</li>
                    <li><strong>Interactive Maps:</strong> View and filter observations from around the world</li>
                    <li><strong>Citizen Science:</strong> Contribute your own observations to help scientists</li>
                    <li><strong>Advanced Analytics:</strong> Explore detailed charts and historical trends</li>
                </ul>
            </div>
            
            <div class="tour-step">
                <h3><i class="fas fa-users me-2"></i>Who Uses BloomWatch Pro?</h3>
                <p>Our platform is used by researchers, educators, conservationists, and nature enthusiasts. Whether you're a scientist studying climate change impacts or a gardener interested in local flowering patterns, BloomWatch Pro provides valuable insights.</p>
                <img src="/hac/images/fourth-img.png" alt="BloomWatch Pro Users">
            </div>
            
            <div class="tour-step">
                <h3><i class="fas fa-leaf me-2"></i>Getting Started</h3>
                <p>Ready to explore? Here's how to get the most out of BloomWatch Pro:</p>
                <ol>
                    <li>Explore the 3D Earth visualization to see global patterns</li>
                    <li>Check out the live data statistics for current global metrics</li>
                    <li>Use the interactive map to find observations in your area</li>
                    <li>Contribute your own observations to help science</li>
                    <li>Explore the analytics section for detailed insights</li>
                </ol>
            </div>
            
            <div class="tour-navigation">
                <button class="btn btn-outline-light" onclick="app.closeTour()">
                    <i class="fas fa-times me-2"></i>Close
                </button>
                <button class="btn btn-primary" onclick="app.startExploring()">
                    <i class="fas fa-play me-2"></i>Start Exploring
                </button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container"></div>

    <!-- Control Panel -->
    <div class="control-panel" id="control-panel">
        <h5><i class="fas fa-gamepad me-2" aria-hidden="true"></i>Automation</h5>
        <button class="control-btn" onclick="app.startProDemo()">
            <i class="fas fa-play me-1" aria-hidden="true"></i>Start Automation
        </button><!--
        <button class="control-btn" onclick="app.toggleProMode()">
            <i class="fas fa-bolt me-1" aria-hidden="true"></i>Pro Mode
        </button>
        <button class="control-btn" onclick="app.showAllMetrics()">
            <i class="fas fa-chart-bar me-1" aria-hidden="true"></i>All Metrics
        </button>
        <button class="control-btn" onclick="app.simulateRealTimeData()">
            <i class="fas fa-sync me-1" aria-hidden="true"></i>Live Data
        </button>
        <button class="control-btn" onclick="app.activateParticleEffects()">
            <i class="fas fa-sparkles me-1" aria-hidden="true"></i>Particles
        </button>-->
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Leaflet Heatmap -->
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
    
    <!-- Leaflet Marker Cluster -->
    <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- GLTFLoader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <!-- Particles.js -->
    <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
    
    <!-- AOS Animation -->
    <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>
    
    <!-- CountUp.js -->
    <script src="https://cdn.jsdelivr.net/npm/countup.js@2.6.2/dist/countUp.umd.js"></script>
    
    <!-- Typed.js -->
    <script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/dist/typed.umd.js"></script>

    <script>
        // BloomWatch Pro Application
        const app = (function() {
            // Private variables
            const config = {
                // Note: Replace with actual API keys in production
                NASA_API_KEY: 'DEMO_KEY', // Use 'DEMO_KEY' for testing
                EARTHDATA_TOKEN: 'YOUR_EARTHDATA_TOKEN',
                GEMINI_API_KEY: 'YOUR_GEMINI_API_KEY',
                DEMO_MODE: false,
                PRO_MODE: false,
                PARTICLES_ENABLED: true,
                TOUR_SHOWN: localStorage.getItem('tourShown') === 'true',
                USE_MOCK_GEMINI: true // Set to true to use mock Gemini responses
            };
            
            const state = {
                earth: null,
                map: null,
                heatmap: null,
                charts: {},
                components: {
                    earth: false,
                    map: false,
                    charts: {},
                    heatmap: false,
                    statsAnimated: false
                },
                demoInterval: null,
                dataUpdateInterval: null,
                particlesInstance: null,
                observers: []
            };
            
            // Private methods
            function initParticles() {
                if (!config.PARTICLES_ENABLED || state.particlesInstance) return;
                
                try {
                    particlesJS('particles-bg', {
                        particles: {
                            number: {
                                value: 100,
                                density: {
                                    enable: true,
                                    value_area: 800
                                }
                            },
                            color: {
                                value: ['#00ff00', '#adff2f', '#ffff00']
                            },
                            shape: {
                                type: 'circle'
                            },
                            opacity: {
                                value: 0.5,
                                random: true,
                                anim: {
                                    enable: true,
                                    speed: 1,
                                    opacity_min: 0.1,
                                    sync: false
                                }
                            },
                            size: {
                                value: 3,
                                random: true,
                                anim: {
                                    enable: true,
                                    speed: 2,
                                    size_min: 0.1,
                                    sync: false
                                }
                            },
                            line_linked: {
                                enable: true,
                                distance: 150,
                                color: '#00ff00',
                                opacity: 0.2,
                                width: 1
                            },
                            move: {
                                enable: true,
                                speed: 1,
                                direction: 'none',
                                random: false,
                                straight: false,
                                out_mode: 'out',
                                bounce: false,
                                attract: {
                                    enable: false,
                                    rotateX: 600,
                                    rotateY: 1200
                                }
                            }
                        },
                        interactivity: {
                            detect_on: 'canvas',
                            events: {
                                onhover: {
                                    enable: true,
                                    mode: 'grab'
                                },
                                onclick: {
                                    enable: true,
                                    mode: 'push'
                                },
                                resize: true
                            },
                            modes: {
                                grab: {
                                    distance: 140,
                                    line_linked: {
                                        opacity: 0.5
                                    }
                                },
                                push: {
                                    particles_nb: 4
                                }
                            }
                        },
                        retina_detect: true
                    });
                    
                    // Store reference to particles instance
                    if (window.pJSDom && window.pJSDom.length > 0) {
                        state.particlesInstance = window.pJSDom[0];
                    }
                } catch (error) {
                    console.error('Error initializing particles:', error);
                }
            }
            
            function initTypedText() {
                try {
                    new Typed('#typed-text', {
                        strings: [
                            'Tracking global flowering phenology through NASA Earth observation and citizen science',
                            'AI-powered platform helping researchers understand climate change impacts',
                            'Protecting biodiversity through advanced phenology monitoring',
                            'Empowering citizen scientists worldwide'
                        ],
                        typeSpeed: 50,
                        backSpeed: 30,
                        loop: true,
                        backDelay: 2000
                    });
                } catch (error) {
                    console.error('Error initializing typed text:', error);
                    // Fallback to static text
                    document.getElementById('typed-text').textContent = 'Tracking global flowering phenology through NASA Earth observation and citizen science';
                }
            }
            
            function initAOS() {
                try {
                    AOS.init({
                        duration: 1000,
                        once: true,
                        offset: 100
                    });
                } catch (error) {
                    console.error('Error initializing AOS:', error);
                }
            }
            
            function initAdvancedEarth() {
                if (state.components.earth) return;
                
                const container = document.getElementById('earth-container');
                if (!container) return;
                
                try {
                    // Hide loading
                    document.getElementById('earth-loading').style.display = 'none';
                    
                    // Scene setup with nearly black background
                    const scene = new THREE.Scene();
                    scene.background = new THREE.Color(0x050505); // Very dark, almost black
                    
                    const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
                    camera.position.set(0, 0, 2.5);
                    
                    const renderer = new THREE.WebGLRenderer({ 
                        antialias: true, 
                        alpha: true,
                        powerPreference: "high-performance"
                    });
                    renderer.setSize(container.clientWidth, container.clientHeight);
                    renderer.setPixelRatio(window.devicePixelRatio);
                    renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    renderer.toneMappingExposure = 1;
                    renderer.shadowMap.enabled = true;
                    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    container.appendChild(renderer.domElement);
                    
                    // Create Earth with enhanced textures
                    const earthGeometry = new THREE.SphereGeometry(1, 128, 128);
                    const textureLoader = new THREE.TextureLoader();
                    
                    // Use high-quality texture sources with fallback
                    let earthTexture, earthNormalMap, earthSpecularMap;
                    
                    try {
                        earthTexture = textureLoader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r129/examples/textures/planets/earth_atmos_2048.jpg');
                    } catch (e) {
                        earthTexture = new THREE.TextureLoader().load(createColorTexture(0x2E7D32));
                    }
                    
                    try {
                        earthNormalMap = textureLoader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r129/examples/textures/planets/earth_normal_2048.jpg');
                    } catch (e) {
                        earthNormalMap = null;
                    }
                    
                    try {
                        earthSpecularMap = textureLoader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r129/examples/textures/planets/earth_specular_2048.jpg');
                    } catch (e) {
                        earthSpecularMap = null;
                    }
                    
                    const earthMaterial = new THREE.MeshPhongMaterial({
                        map: earthTexture,
                        normalMap: earthNormalMap,
                        normalScale: new THREE.Vector2(0.15, 0.15),
                        specularMap: earthSpecularMap,
                        specular: new THREE.Color('grey'),
                        shininess: 15
                    });
                    
                    const earth = new THREE.Mesh(earthGeometry, earthMaterial);
                    earth.castShadow = true;
                    earth.receiveShadow = true;
                    scene.add(earth);
                    
                    // Create enhanced atmosphere with realistic glow
                    const atmosphereGeometry = new THREE.SphereGeometry(1.05, 64, 64);
                    const atmosphereMaterial = new THREE.ShaderMaterial({
                        vertexShader: `
                            varying vec3 vNormal;
                            varying vec3 vPosition;
                            void main() {
                                vNormal = normalize(normalMatrix * normal);
                                vPosition = position;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            varying vec3 vNormal;
                            varying vec3 vPosition;
                            void main() {
                                float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                                vec3 atmosphereColor = vec3(0.3, 0.6, 1.0);
                                float edgeFactor = 1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0)));
                                float rimLight = pow(edgeFactor, 2.0) * 0.5;
                                gl_FragColor = vec4(atmosphereColor, 1.0) * (intensity + rimLight);
                            }
                        `,
                        blending: THREE.AdditiveBlending,
                        side: THREE.BackSide,
                        transparent: true
                    });
                    
                    const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
                    scene.add(atmosphere);
                    
                    // Create realistic clouds with better texture
                    const cloudGeometry = new THREE.SphereGeometry(1.01, 64, 64);
                    let cloudTexture;
                    
                    try {
                        cloudTexture = textureLoader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r129/examples/textures/planets/earth_clouds_1024.png');
                    } catch (e) {
                        cloudTexture = null;
                    }
                    
                    const cloudMaterial = new THREE.MeshPhongMaterial({
                        map: cloudTexture,
                        transparent: true,
                        opacity: 0.3,
                        depthWrite: false
                    });
                    
                    const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    scene.add(clouds);
                    
                    // Enhanced lighting with sun
                    const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
                    scene.add(ambientLight);
                    
                    const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
                    sunLight.position.set(5, 3, 5);
                    sunLight.castShadow = true;
                    sunLight.shadow.mapSize.width = 2048;
                    sunLight.shadow.mapSize.height = 2048;
                    scene.add(sunLight);
                    
                    // Add subtle back light for rim effect
                    const backLight = new THREE.DirectionalLight(0x4080ff, 0.5);
                    backLight.position.set(-5, -3, -5);
                    scene.add(backLight);
                    
                    // Create satellites
                    const satellites = [];
                    const satelliteOrbits = [];
                    
                    // ISS (International Space Station)
                    const iss = createISS();
                    iss.userData = {
                        orbitRadius: 1.15,
                        orbitSpeed: 0.001,
                        angle: Math.random() * Math.PI * 2,
                        inclination: 0.5
                    };
                    scene.add(iss);
                    satellites.push(iss);
                    
                    // GPS Satellites
                    for (let i = 0; i < 6; i++) {
                        const gpsSat = createGPSSatellite();
                        gpsSat.userData = {
                            orbitRadius: 1.3 + Math.random() * 0.1,
                            orbitSpeed: 0.0008 + Math.random() * 0.0002,
                            angle: (Math.PI * 2 / 6) * i,
                            inclination: 0.8 + Math.random() * 0.4
                        };
                        scene.add(gpsSat);
                        satellites.push(gpsSat);
                    }
                    
                    // Communication Satellites
                    for (let i = 0; i < 4; i++) {
                        const commSat = createCommunicationSatellite();
                        commSat.userData = {
                            orbitRadius: 1.25 + Math.random() * 0.05,
                            orbitSpeed: 0.0006 + Math.random() * 0.0001,
                            angle: (Math.PI * 2 / 4) * i + Math.random() * 0.5,
                            inclination: 0.2 + Math.random() * 0.3
                        };
                        scene.add(commSat);
                        satellites.push(commSat);
                    }
                    
                    // Starlink-like constellation
                    for (let i = 0; i < 12; i++) {
                        const starlinkSat = createStarlinkSatellite();
                        starlinkSat.userData = {
                            orbitRadius: 1.1 + Math.random() * 0.02,
                            orbitSpeed: 0.002 + Math.random() * 0.0005,
                            angle: (Math.PI * 2 / 12) * i + Math.random() * 0.3,
                            inclination: 1.2 + Math.random() * 0.2
                        };
                        scene.add(starlinkSat);
                        satellites.push(starlinkSat);
                    }
                    
                    // Weather Satellite
                    const weatherSat = createWeatherSatellite();
                    weatherSat.userData = {
                        orbitRadius: 1.35,
                        orbitSpeed: 0.0005,
                        angle: Math.random() * Math.PI * 2,
                        inclination: 0
                    };
                    scene.add(weatherSat);
                    satellites.push(weatherSat);
                    
                    // Create orbital paths
                    satellites.forEach(sat => {
                        const orbitPath = createOrbitPath(sat.userData.orbitRadius, sat.userData.inclination);
                        scene.add(orbitPath);
                        satelliteOrbits.push(orbitPath);
                    });
                    
                    // Add data points with enhanced appearance
                    const dataPoints = [];
                    const phenologyHotspots = [
                        { lat: 40.7128, lng: -74.0060, intensity: 0.9 },
                        { lat: 51.5074, lng: -0.1278, intensity: 0.8 },
                        { lat: 35.6895, lng: 139.6917, intensity: 0.95 },
                        { lat: -33.8688, lng: 151.2093, intensity: 0.7 },
                        { lat: 48.8566, lng: 2.3522, intensity: 0.85 },
                        { lat: 55.7558, lng: 37.6173, intensity: 0.6 },
                        { lat: -22.9068, lng: -43.1729, intensity: 0.8 },
                        { lat: 1.3521, lng: 103.8198, intensity: 0.9 }
                    ];
                    
                    phenologyHotspots.forEach(hotspot => {
                        for (let i = 0; i < 15; i++) {
                            const latOffset = (Math.random() - 0.5) * 8;
                            const lngOffset = (Math.random() - 0.5) * 8;
                            const lat = hotspot.lat + latOffset;
                            const lng = hotspot.lng + lngOffset;
                            const phi = (90 - lat) * Math.PI / 180;
                            const theta = (lng + 180) * Math.PI / 180;
                            
                            const x = -(1.02 * Math.sin(phi) * Math.cos(theta));
                            const y = 1.02 * Math.cos(phi);
                            const z = 1.02 * Math.sin(phi) * Math.sin(theta);
                            
                            dataPoints.push(x, y, z);
                        }
                    });
                    
                    const pointsGeometry = new THREE.BufferGeometry();
                    pointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dataPoints, 3));
                    
                    // Create sprite texture for data points
                    const spriteTexture = createSpriteTexture();
                    
                    const pointsMaterial = new THREE.PointsMaterial({
                        map: spriteTexture,
                        color: 0xff5555,
                        size: 0.03,
                        transparent: true,
                        opacity: 0.8,
                        blending: THREE.AdditiveBlending,
                        depthTest: false
                    });
                    
                    const bloomPoints = new THREE.Points(pointsGeometry, pointsMaterial);
                    scene.add(bloomPoints);
                    
                    // ===== NEW MOON IMPLEMENTATION =====
                    // Create Moon
                    const moonGeometry = new THREE.SphereGeometry(0.27, 64, 64); // Moon is ~27% Earth's size
                    let moonTexture;
                    
                    try {
                        moonTexture = textureLoader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r129/examples/textures/planets/moon_1024.jpg');
                    } catch (e) {
                        moonTexture = new THREE.TextureLoader().load(createColorTexture(0xAAAAAA));
                    }
                    
                    const moonMaterial = new THREE.MeshPhongMaterial({
                        map: moonTexture,
                        shininess: 5
                    });
                    
                    const moon = new THREE.Mesh(moonGeometry, moonMaterial);
                    moon.castShadow = true;
                    moon.receiveShadow = true;
                    
                    // Create Moon orbit group
                    const moonOrbitGroup = new THREE.Group();
                    moonOrbitGroup.add(moon);
                    moon.position.set(3, 0, 0); // Position Moon 3 units from Earth
                    scene.add(moonOrbitGroup);
                    
                    // Create Moon satellites
                    const moonSatellites = [];
                    const moonSatelliteOrbits = [];
                    
                    // Lunar Reconnaissance Orbiter
                    const lro = createLunarSatellite();
                    lro.userData = {
                        orbitRadius: 0.35,
                        orbitSpeed: 0.003,
                        angle: Math.random() * Math.PI * 2,
                        inclination: 0.2
                    };
                    moon.add(lro);
                    moonSatellites.push(lro);
                    
                    // Chandrayaan-like orbiter
                    const chandrayaan = createLunarSatellite();
                    chandrayaan.userData = {
                        orbitRadius: 0.4,
                        orbitSpeed: 0.0025,
                        angle: Math.random() * Math.PI * 2,
                        inclination: 0.5
                    };
                    moon.add(chandrayaan);
                    moonSatellites.push(chandrayaan);
                    
                    // Create Moon satellite orbits
                    moonSatellites.forEach(sat => {
                        const orbitPath = createOrbitPath(sat.userData.orbitRadius, sat.userData.inclination);
                        moon.add(orbitPath);
                        moonSatelliteOrbits.push(orbitPath);
                    });
                    
                    // Create Moon orbit path around Earth
                    const moonOrbitPath = createOrbitPath(3, 0);
                    scene.add(moonOrbitPath);
                    
                    // Mouse interaction
                    let mouseX = 0, mouseY = 0;
                    let isDragging = false;
                    let previousMousePosition = { x: 0, y: 0 };
                    
                    container.addEventListener('mousedown', () => isDragging = true);
                    container.addEventListener('mouseup', () => isDragging = false);
                    container.addEventListener('mouseleave', () => isDragging = false);
                    
                    container.addEventListener('mousemove', (e) => {
                        const rect = container.getBoundingClientRect();
                        mouseX = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                        mouseY = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                        
                        if (isDragging) {
                            const deltaMove = {
                                x: e.offsetX - previousMousePosition.x,
                                y: e.offsetY - previousMousePosition.y
                            };
                            
                            earth.rotation.y += deltaMove.x * 0.01;
                            clouds.rotation.y += deltaMove.x * 0.01;
                            bloomPoints.rotation.y += deltaMove.x * 0.01;
                            atmosphere.rotation.y += deltaMove.x * 0.01;
                            moonOrbitGroup.rotation.y += deltaMove.x * 0.01;
                            
                            // Rotate satellites and orbits
                            satellites.forEach(sat => {
                                sat.rotation.y += deltaMove.x * 0.01;
                                sat.rotation.x += deltaMove.y * 0.01;
                            });
                            satelliteOrbits.forEach(orbit => {
                                orbit.rotation.y += deltaMove.x * 0.01;
                                orbit.rotation.x += deltaMove.y * 0.01;
                            });
                            
                            earth.rotation.x += deltaMove.y * 0.01;
                            clouds.rotation.x += deltaMove.y * 0.01;
                            bloomPoints.rotation.x += deltaMove.y * 0.01;
                            atmosphere.rotation.x += deltaMove.y * 0.01;
                            moonOrbitGroup.rotation.x += deltaMove.y * 0.01;
                        }
                        
                        previousMousePosition = { x: e.offsetX, y: e.offsetY };
                    });
                    
                    // Touch events for mobile
                    let touchStartX = 0;
                    let touchStartY = 0;
                    
                    container.addEventListener('touchstart', (e) => {
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                        isDragging = true;
                    });
                    
                    container.addEventListener('touchmove', (e) => {
                        if (!isDragging) return;
                        
                        const touchX = e.touches[0].clientX;
                        const touchY = e.touches[0].clientY;
                        const deltaX = touchX - touchStartX;
                        const deltaY = touchY - touchStartY;
                        
                        earth.rotation.y += deltaX * 0.01;
                        clouds.rotation.y += deltaX * 0.01;
                        bloomPoints.rotation.y += deltaX * 0.01;
                        atmosphere.rotation.y += deltaX * 0.01;
                        moonOrbitGroup.rotation.y += deltaX * 0.01;
                        
                        // Rotate satellites and orbits
                        satellites.forEach(sat => {
                            sat.rotation.y += deltaX * 0.01;
                            sat.rotation.x += deltaY * 0.01;
                        });
                        satelliteOrbits.forEach(orbit => {
                            orbit.rotation.y += deltaX * 0.01;
                            orbit.rotation.x += deltaY * 0.01;
                        });
                        
                        earth.rotation.x += deltaY * 0.01;
                        clouds.rotation.x += deltaY * 0.01;
                        bloomPoints.rotation.x += deltaY * 0.01;
                        atmosphere.rotation.x += deltaY * 0.01;
                        moonOrbitGroup.rotation.x += deltaY * 0.01;
                        
                        touchStartX = touchX;
                        touchStartY = touchY;
                    });
                    
                    container.addEventListener('touchend', () => {
                        isDragging = false;
                    });
                    
                    // Zoom with mouse wheel
                    container.addEventListener('wheel', (e) => {
                        e.preventDefault();
                        camera.position.z += e.deltaY * 0.001;
                        camera.position.z = Math.min(Math.max(camera.position.z, 1.5), 5);
                    });
                    
                    // Animation
                    let earthRotating = true;
                    function animate() {
                        requestAnimationFrame(animate);
                        
                        if (earthRotating) {
                            earth.rotation.y += 0.0005;
                            clouds.rotation.y += 0.0007;
                            bloomPoints.rotation.y += 0.0005;
                            atmosphere.rotation.y += 0.0005;
                        }
                        
                        // Animate Moon orbit
                        moonOrbitGroup.rotation.y += 0.0002; // Slower orbit than Earth rotation
                        
                        // Animate Moon rotation
                        moon.rotation.y += 0.0005;
                        
                        // Animate satellites
                        satellites.forEach(sat => {
                            sat.userData.angle += sat.userData.orbitSpeed;
                            const x = Math.cos(sat.userData.angle) * sat.userData.orbitRadius;
                            const z = Math.sin(sat.userData.angle) * sat.userData.orbitRadius;
                            const y = Math.sin(sat.userData.angle) * Math.sin(sat.userData.inclination) * sat.userData.orbitRadius * 0.3;
                            
                            sat.position.set(x, y, z);
                            
                            // Rotate satellite to face Earth
                            sat.lookAt(0, 0, 0);
                        });
                        
                        // Animate Moon satellites
                        moonSatellites.forEach(sat => {
                            sat.userData.angle += sat.userData.orbitSpeed;
                            const x = Math.cos(sat.userData.angle) * sat.userData.orbitRadius;
                            const z = Math.sin(sat.userData.angle) * sat.userData.orbitRadius;
                            const y = Math.sin(sat.userData.angle) * Math.sin(sat.userData.inclination) * sat.userData.orbitRadius * 0.3;
                            
                            sat.position.set(x, y, z);
                            
                            // Rotate satellite to face Moon
                            sat.lookAt(0, 0, 0);
                        });
                        
                        // Camera follows mouse slightly
                        camera.position.x += (mouseX * 0.1 - camera.position.x) * 0.05;
                        camera.position.y += (mouseY * 0.1 - camera.position.y) * 0.05;
                        camera.lookAt(0, 0, 0);
                        
                        renderer.render(scene, camera);
                    }
                    
                    animate();
                    
                    // Handle resize
                    const handleResize = debounce(() => {
                        camera.aspect = container.clientWidth / container.clientHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(container.clientWidth, container.clientHeight);
                    }, 250);
                    
                    window.addEventListener('resize', handleResize);
                    
                    // Store references
                    state.earth = {
                        scene, camera, renderer, earth, clouds, atmosphere, bloomPoints,
                        satellites, satelliteOrbits, moon, moonOrbitGroup, moonSatellites, moonSatelliteOrbits,
                        toggleRotation: () => { earthRotating = !earthRotating; },
                        toggleAtmosphere: () => { atmosphere.visible = !atmosphere.visible; },
                        toggleClouds: () => { clouds.visible = !clouds.visible; },
                        toggleDataPoints: () => { bloomPoints.visible = !bloomPoints.visible; },
                        toggleSatellites: () => { 
                            satellites.forEach(sat => sat.visible = !sat.visible);
                            satelliteOrbits.forEach(orbit => orbit.visible = !orbit.visible);
                        },
                        toggleMoon: () => { moonOrbitGroup.visible = !moonOrbitGroup.visible; },
                        toggleMoonSatellites: () => { 
                            moonSatellites.forEach(sat => sat.visible = !sat.visible);
                            moonSatelliteOrbits.forEach(orbit => orbit.visible = !orbit.visible);
                        },
                        cleanup: () => {
                            window.removeEventListener('resize', handleResize);
                            renderer.dispose();
                            container.removeChild(renderer.domElement);
                        }
                    };
                    
                    state.components.earth = true;
                } catch (error) {
                    console.error('Error initializing 3D Earth:', error);
                    document.getElementById('earth-loading').innerHTML = '<div class="text-center p-4">Error loading 3D Earth. Please refresh the page.</div>';
                }
            }
            
            // NEW: Lunar satellite creation function
            function createLunarSatellite() {
                const group = new THREE.Group();
                
                // Main body
                const bodyGeometry = new THREE.BoxGeometry(0.01, 0.008, 0.01);
                const bodyMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xcccccc,
                    emissive: 0x111111
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                group.add(body);
                
                // Solar panels
                const panelGeometry = new THREE.BoxGeometry(0.02, 0.0008, 0.01);
                const panelMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x1a1a2e,
                    emissive: 0x0f3460
                });
                
                const panel1 = new THREE.Mesh(panelGeometry, panelMaterial);
                panel1.position.x = -0.015;
                group.add(panel1);
                
                const panel2 = new THREE.Mesh(panelGeometry, panelMaterial);
                panel2.position.x = 0.015;
                group.add(panel2);
                
                // Antenna
                const antennaGeometry = new THREE.CylinderGeometry(0.001, 0.001, 0.02, 8);
                const antennaMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffffff
                });
                const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                antenna.position.y = 0.01;
                group.add(antenna);
                
                return group;
            }
            
            // Satellite creation functions (unchanged)
            function createISS() {
                const group = new THREE.Group();
                
                // Main body
                const bodyGeometry = new THREE.BoxGeometry(0.02, 0.01, 0.03);
                const bodyMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffffff,
                    emissive: 0x222222,
                    shininess: 100
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                group.add(body);
                
                // Solar panels
                const panelGeometry = new THREE.BoxGeometry(0.08, 0.001, 0.02);
                const panelMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x1a1a2e,
                    emissive: 0x0f3460,
                    shininess: 50
                });
                
                const leftPanel = new THREE.Mesh(panelGeometry, panelMaterial);
                leftPanel.position.x = -0.05;
                group.add(leftPanel);
                
                const rightPanel = new THREE.Mesh(panelGeometry, panelMaterial);
                rightPanel.position.x = 0.05;
                group.add(rightPanel);
                
                // Add small lights
                const lightGeometry = new THREE.SphereGeometry(0.002, 8, 8);
                const lightMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000
                });
                const light = new THREE.Mesh(lightGeometry, lightMaterial);
                light.position.z = 0.015;
                group.add(light);
                
                return group;
            }
            
            function createGPSSatellite() {
                const group = new THREE.Group();
                
                // Main body
                const bodyGeometry = new THREE.BoxGeometry(0.015, 0.01, 0.015);
                const bodyMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xcccccc,
                    emissive: 0x111111
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                group.add(body);
                
                // Solar panels
                const panelGeometry = new THREE.BoxGeometry(0.04, 0.001, 0.015);
                const panelMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x1a1a2e,
                    emissive: 0x0f3460
                });
                
                const panel1 = new THREE.Mesh(panelGeometry, panelMaterial);
                panel1.position.x = -0.03;
                group.add(panel1);
                
                const panel2 = new THREE.Mesh(panelGeometry, panelMaterial);
                panel2.position.x = 0.03;
                group.add(panel2);
                
                return group;
            }
            
            function createCommunicationSatellite() {
                const group = new THREE.Group();
                
                // Main body
                const bodyGeometry = new THREE.CylinderGeometry(0.008, 0.008, 0.02, 8);
                const bodyMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffd700,
                    emissive: 0x444400
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.rotation.z = Math.PI / 2;
                group.add(body);
                
                // Dish antenna
                const dishGeometry = new THREE.ConeGeometry(0.015, 0.005, 16);
                const dishMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffffff,
                    emissive: 0x222222
                });
                const dish = new THREE.Mesh(dishGeometry, dishMaterial);
                dish.position.x = 0.015;
                dish.rotation.z = -Math.PI / 2;
                group.add(dish);
                
                return group;
            }
            
            function createStarlinkSatellite() {
                const group = new THREE.Group();
                
                // Flat panel body
                const bodyGeometry = new THREE.BoxGeometry(0.02, 0.002, 0.01);
                const bodyMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x333333,
                    emissive: 0x111111
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                group.add(body);
                
                // Solar panel (same as body for Starlink)
                const panel = new THREE.Mesh(bodyGeometry, bodyMaterial);
                panel.position.y = 0.003;
                group.add(panel);
                
                return group;
            }
            
            function createWeatherSatellite() {
                const group = new THREE.Group();
                
                // Main body
                const bodyGeometry = new THREE.BoxGeometry(0.02, 0.015, 0.02);
                const bodyMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x4169e1,
                    emissive: 0x111144
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                group.add(body);
                
                // Large solar panel
                const panelGeometry = new THREE.BoxGeometry(0.06, 0.001, 0.02);
                const panelMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x1a1a2e,
                    emissive: 0x0f3460
                });
                const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                panel.position.x = 0.04;
                group.add(panel);
                
                // Sensor dish
                const dishGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.005, 16);
                const dishMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xc0c0c0,
                    emissive: 0x222222
                });
                const dish = new THREE.Mesh(dishGeometry, dishMaterial);
                dish.position.y = 0.015;
                group.add(dish);
                
                return group;
            }
            
            function createOrbitPath(radius, inclination) {
                const curve = new THREE.EllipseCurve(
                    0, 0,
                    radius, radius * Math.cos(inclination),
                    0, 2 * Math.PI,
                    false,
                    0
                );
                
                const points = curve.getPoints(100);
                const geometry = new THREE.BufferGeometry().setFromPoints(
                    points.map(p => new THREE.Vector3(p.x, 0, p.y))
                );
                
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x444444,
                    transparent: true,
                    opacity: 0.3
                });
                
                return new THREE.Line(geometry, material);
            }
            
            function createColorTexture(color) {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const context = canvas.getContext('2d');
                context.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
                context.fillRect(0, 0, 256, 256);
                return canvas.toDataURL();
            }
            
            function createSpriteTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                
                // Create gradient for glow effect
                const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                gradient.addColorStop(0.2, 'rgba(255, 100, 100, 0.8)');
                gradient.addColorStop(0.5, 'rgba(255, 50, 50, 0.5)');
                gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                
                context.fillStyle = gradient;
                context.fillRect(0, 0, 64, 64);
                
                return new THREE.CanvasTexture(canvas);
            }
            
            function debounce(func, wait) {
                let timeout;
                return function() {
                    const context = this, args = arguments;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(context, args), wait);
                };
            }
            
           function initMap() {
    if (state.components.map) return;
    
    const mapContainer = document.getElementById('map');
    if (!mapContainer) return;
    
    try {
        document.getElementById('map-loading').style.display = 'none';
        
        // Create map
        state.map = L.map('map').setView([20, 0], 2);
        
        // Add realistic tile layer (replaced dark theme with OpenStreetMap)
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            maxZoom: 19
        }).addTo(state.map);
        
        // Initialize marker cluster
        const markerClusterGroup = L.markerClusterGroup({
            iconCreateFunction: function(cluster) {
                const count = cluster.getChildCount();
                let size = 'small';
                if (count > 50) size = 'large';
                else if (count > 10) size = 'medium';
                
                return L.divIcon({
                    html: `<div style="background: linear-gradient(135deg, #00ff00, #adff2f); color: white; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-weight: bold;">${count}</div>`,
                    className: 'custom-cluster-icon',
                    iconSize: L.point(40, 40)
                });
            }
        });
        
        state.map.addLayer(markerClusterGroup);
        
        // Add sample data points from multiple sources
        const flowerLocations = [
            // USA-NPN data
            { lat: 40.7128, lng: -74.0060, name: "New York", species: "Cherry Blossom", stage: "peak", source: "USA-NPN" },
            { lat: 41.8781, lng: -87.6298, name: "Chicago", species: "Tulip", stage: "early", source: "USA-NPN" },
            { lat: 34.0522, lng: -118.2437, name: "Los Angeles", species: "California Poppy", stage: "peak", source: "USA-NPN" },
            
            // GLOBE Observer data
            { lat: 51.5074, lng: -0.1278, name: "London", species: "Bluebell", stage: "early", source: "GLOBE Observer" },
            { lat: 48.8566, lng: 2.3522, name: "Paris", species: "Lilac", stage: "early", source: "GLOBE Observer" },
            { lat: 52.5200, lng: 13.4050, name: "Berlin", species: "Cherry Blossom", stage: "peak", source: "GLOBE Observer" },
            
            // GBIF data
            { lat: 35.6895, lng: 139.6917, name: "Tokyo", species: "Sakura", stage: "late", source: "GBIF" },
            { lat: -33.8688, lng: 151.2093, name: "Sydney", species: "Golden Wattle", stage: "peak", source: "GBIF" },
            { lat: -37.8136, lng: 144.9631, name: "Melbourne", species: "Eucalyptus", stage: "peak", source: "GBIF" },
            
            // iNaturalist data
            { lat: 55.7558, lng: 37.6173, name: "Moscow", species: "Lily of the Valley", stage: "buds", source: "iNaturalist" },
            { lat: -22.9068, lng: -43.1729, name: "Rio de Janeiro", species: "Ipê", stage: "peak", source: "iNaturalist" },
            { lat: 1.3521, lng: 103.8198, name: "Singapore", species: "Orchid", stage: "peak", source: "iNaturalist" },
            
            // Additional data points
            { lat: 37.7749, lng: -122.4194, name: "San Francisco", species: "California Poppy", stage: "early", source: "USA-NPN" },
            { lat: -26.2041, lng: 28.0473, name: "Johannesburg", species: "Protea", stage: "peak", source: "GBIF" },
            { lat: 19.4326, lng: -99.1332, name: "Mexico City", species: "Dahlia", stage: "late", source: "iNaturalist" },
            { lat: 28.6139, lng: 77.2090, name: "New Delhi", species: "Lotus", stage: "peak", source: "GBIF" }
        ];
        
        flowerLocations.forEach(location => {
            const color = getStageColor(location.stage);
            const marker = L.circleMarker([location.lat, location.lng], {
                radius: 10,
                fillColor: color,
                color: '#fff',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.8
            });
            
            marker.bindPopup(`
                <div style="text-align: center;">
                    <h4>${location.name}</h4>
                    <p><strong>Species:</strong> ${location.species}</p>
                    <p><strong>Stage:</strong> ${location.stage}</p>
                    <p><strong>Source:</strong> ${location.source}</p>
                </div>
            `);
            
            markerClusterGroup.addLayer(marker);
        });
        
        state.map.markerClusterGroup = markerClusterGroup;
        state.components.map = true;
    } catch (error) {
        console.error('Error initializing map:', error);
        document.getElementById('map-loading').innerHTML = '<div class="text-center p-4">Error loading map. Please refresh the page.</div>';
    }
}

// Helper function to get color based on flowering stage
function getStageColor(stage) {
    const colors = {
        'buds': '#9370DB',    // MediumPurple
        'early': '#00BFFF',   // DeepSkyBlue
        'peak': '#32CD32',    // LimeGreen
        'late': '#FF8C00'     // DarkOrange
    };
    return colors[stage] || '#808080'; // Default gray
}
function getStageColor(stage) {
                const colors = {
                    'buds': '#8BC34A',
                    'early': '#FFEB3B',
                    'peak': '#FF5722',
                    'late': '#9C27B0',
                    'finished': '#607D8B'
                };
                return colors[stage] || '#03A9F4';
            }
            
            function initCharts() {
                try {
                    // Temperature vs Flowering Chart
                    const tempCtx = document.getElementById('tempFloweringChart');
                    if (tempCtx && !state.components.charts.tempFlowering) {
                        state.charts.tempFlowering = new Chart(tempCtx, {
                            type: 'scatter',
                            data: {
                                datasets: [
                                    {
                                        label: 'Early Spring Species',
                                        data: [
                                            { x: 4.2, y: 16 }, { x: 5.3, y: 13 }, { x: 6.4, y: 10 },
                                            { x: 7.5, y: 7 }, { x: 8.6, y: 4 }
                                        ],
                                        backgroundColor: 'rgba(255, 99, 132, 0.6)',
                                        borderColor: 'rgba(255, 99, 132, 1)',
                                        borderWidth: 2
                                    },
                                    {
                                        label: 'Mid-Spring Species',
                                        data: [
                                            { x: 9.2, y: 26 }, { x: 10.3, y: 23 }, { x: 11.4, y: 20 },
                                            { x: 12.5, y: 17 }, { x: 13.6, y: 14 }
                                        ],
                                        backgroundColor: 'rgba(54, 162, 235, 0.6)',
                                        borderColor: 'rgba(54, 162, 235, 1)',
                                        borderWidth: 2
                                    },
                                    {
                                        label: 'Late Spring Species',
                                        data: [
                                            { x: 14.2, y: 36 }, { x: 15.3, y: 33 }, { x: 16.4, y: 30 },
                                            { x: 17.5, y: 27 }, { x: 18.6, y: 24 }
                                        ],
                                        backgroundColor: 'rgba(75, 192, 192, 0.6)',
                                        borderColor: 'rgba(75, 192, 192, 1)',
                                        borderWidth: 2
                                    }
                                ]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    legend: {
                                        labels: { color: '#fff' }
                                    },
                                    title: {
                                        display: true,
                                        text: 'Temperature vs. Flowering Time Correlation',
                                        color: '#fff',
                                        font: { size: 16 }
                                    }
                                },
                                scales: {
                                    y: {
                                        title: {
                                            display: true,
                                            text: 'Days Since Jan 1',
                                            color: '#fff'
                                        },
                                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                        ticks: { color: '#fff' }
                                    },
                                    x: {
                                        title: {
                                            display: true,
                                            text: 'Average Spring Temperature (°C)',
                                            color: '#fff'
                                        },
                                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                        ticks: { color: '#fff' }
                                    }
                                }
                            }
                        });
                        state.components.charts.tempFlowering = true;
                    }
                    
                    // Historical Trends Chart
                    const historicalCtx = document.getElementById('historicalTrendsChart');
                    if (historicalCtx && !state.components.charts.historical) {
                        state.charts.historical = new Chart(historicalCtx, {
                            type: 'line',
                            data: {
                                labels: ['1950', '1960', '1970', '1980', '1990', '2000', '2010', '2020', '2025'],
                                datasets: [
                                    {
                                        label: 'Average Flowering Date',
                                        data: [128, 126, 123, 120, 117, 112, 107, 102, 98],
                                        borderColor: '#00ff00',
                                        backgroundColor: 'rgba(0, 255, 0, 0.1)',
                                        tension: 0.4,
                                        fill: true
                                    },
                                    {
                                        label: 'Spring Temperature',
                                        data: [8.1, 8.3, 8.6, 8.9, 9.4, 10.1, 10.7, 11.4, 11.8],
                                        borderColor: '#adff2f',
                                        backgroundColor: 'rgba(173, 255, 47, 0.1)',
                                        tension: 0.4,
                                        fill: true,
                                        yAxisID: 'y1'
                                    }
                                ]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    legend: {
                                        labels: { color: '#fff' }
                                    },
                                    title: {
                                        display: true,
                                        text: '75-Year Historical Analysis',
                                        color: '#fff',
                                        font: { size: 16 }
                                    }
                                },
                                scales: {
                                    y: {
                                        type: 'linear',
                                        display: true,
                                        position: 'left',
                                        title: {
                                            display: true,
                                            text: 'Days Since Jan 1',
                                            color: '#fff'
                                        },
                                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                        ticks: { color: '#fff' }
                                    },
                                    y1: {
                                        type: 'linear',
                                        display: true,
                                        position: 'right',
                                        title: {
                                            display: true,
                                            text: 'Temperature (°C)',
                                            color: '#fff'
                                        },
                                        grid: { drawOnChartArea: false },
                                        ticks: { color: '#fff' }
                                    },
                                    x: {
                                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                        ticks: { color: '#fff' }
                                    }
                                }
                            }
                        });
                        state.components.charts.historical = true;
                    }
                    
                    // Climate Impact Chart
                    const climateCtx = document.getElementById('climateImpactChart');
                    if (climateCtx && !state.components.charts.climate) {
                        state.charts.climate = new Chart(climateCtx, {
                            type: 'bar',
                            data: {
                                labels: ['2025', '2030', '2035', '2040', '2045', '2050'],
                                datasets: [
                                    {
                                        label: 'Flowering Advancement (Days)',
                                        data: [5, 10, 15, 20, 25, 30],
                                        backgroundColor: 'rgba(0, 255, 0, 0.6)',
                                        borderColor: 'rgba(0, 255, 0, 1)',
                                        borderWidth: 2
                                    },
                                    {
                                        label: 'Species at Risk (%)',
                                        data: [12, 22, 35, 45, 55, 65],
                                        backgroundColor: 'rgba(173, 255, 47, 0.6)',
                                        borderColor: 'rgba(173, 255, 47, 1)',
                                        borderWidth: 2
                                    }
                                ]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    legend: {
                                        labels: { color: '#fff' }
                                    },
                                    title: {
                                        display: true,
                                        text: 'Climate Impact Projections (RCP 4.5)',
                                        color: '#fff',
                                        font: { size: 16 }
                                    }
                                },
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                        ticks: { color: '#fff' }
                                    },
                                    x: {
                                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                        ticks: { color: '#fff' }
                                    }
                                }
                            }
                        });
                        state.components.charts.climate = true;
                    }
                    
                    // Phenology Chart
                    const phenologyCtx = document.getElementById('phenologyChart');
                    if (phenologyCtx && !state.components.charts.phenology) {
                        const gradient1 = phenologyCtx.getContext('2d').createLinearGradient(0, 0, 0, 400);
                        gradient1.addColorStop(0, 'rgba(0, 255, 0, 0.6)');
                        gradient1.addColorStop(1, 'rgba(0, 255, 0, 0.1)');
                        
                        const gradient2 = phenologyCtx.getContext('2d').createLinearGradient(0, 0, 0, 400);
                        gradient2.addColorStop(0, 'rgba(173, 255, 47, 0.6)');
                        gradient2.addColorStop(1, 'rgba(173, 255, 47, 0.1)');
                        
                        state.charts.phenology = new Chart(phenologyCtx, {
                            type: 'line',
                            data: {
                                labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                                datasets: [
                                    {
                                        label: 'Northern Hemisphere',
                                        data: [1, 3, 25, 68, 92, 75, 48, 32, 20, 10, 4, 2],
                                        borderColor: '#00ff00',
                                        backgroundColor: gradient1,
                                        tension: 0.4,
                                        fill: true
                                    },
                                    {
                                        label: 'Southern Hemisphere',
                                        data: [68, 48, 32, 10, 2, 1, 3, 18, 35, 60, 75, 70],
                                        borderColor: '#adff2f',
                                        backgroundColor: gradient2,
                                        tension: 0.4,
                                        fill: true
                                    }
                                ]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    legend: {
                                        labels: { color: '#fff' }
                                    },
                                    title: {
                                        display: true,
                                        text: 'Seasonal Flowering Intensity',
                                        color: '#fff',
                                        font: { size: 16 }
                                    }
                                },
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                        ticks: { color: '#fff' },
                                        title: {
                                            display: true,
                                            text: 'Flowering Intensity (%)',
                                            color: '#fff'
                                        }
                                    },
                                    x: {
                                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                        ticks: { color: '#fff' }
                                    }
                                }
                            }
                        });
                        state.components.charts.phenology = true;
                    }
                    
                    // Seasonal Chart
                    const seasonalCtx = document.getElementById('seasonalChart');
                    if (seasonalCtx && !state.components.charts.seasonal) {
                        const gradient = seasonalCtx.getContext('2d').createLinearGradient(0, 0, 0, 250);
                        gradient.addColorStop(0, 'rgba(173, 255, 47, 0.6)');
                        gradient.addColorStop(1, 'rgba(173, 255, 47, 0.1)');
                        
                        state.charts.seasonal = new Chart(seasonalCtx, {
                            type: 'line',
                            data: {
                                labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                                datasets: [
                                    {
                                        label: 'Historical Average',
                                        data: [1, 3, 25, 68, 92, 75, 48, 32, 20, 10, 4, 2],
                                        borderColor: '#00ff00',
                                        backgroundColor: 'rgba(0, 255, 0, 0.1)',
                                        tension: 0.4,
                                        fill: false
                                    },
                                    {
                                        label: '2025 Prediction',
                                        data: [3, 7, 35, 78, 95, 80, 52, 35, 25, 15, 7, 4],
                                        borderColor: '#adff2f',
                                        backgroundColor: gradient,
                                        tension: 0.4,
                                        fill: true
                                    }
                                ]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    legend: {
                                        labels: { color: '#fff' }
                                    }
                                },
                                scales: {
                                    y: {
                                        beginAtZero: true,
                                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                        ticks: { color: '#fff' }
                                    },
                                    x: {
                                        grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                        ticks: { color: '#fff' }
                                    }
                                }
                            }
                        });
                        state.components.charts.seasonal = true;
                    }
                } catch (error) {
                    console.error('Error initializing charts:', error);
                }
            }
       
            



function init3DSpeciesChart() {
    if (state.components.charts.species3d) return;
    
    const container = document.getElementById('species3dChart');
    if (!container) return;
    
    try {
        document.getElementById('species3d-loading').style.display = 'none';
        
        // Enhanced scene setup for microscopic view
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a1f0b);
        scene.fog = new THREE.FogExp2(0x0a1f0b, 0.015);
        
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.01, 1000);
        camera.position.set(0, 0, 60);
        
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        container.appendChild(renderer.domElement);
        
        // Create mobile controls container
        const mobileControls = document.createElement('div');
        mobileControls.className = 'mobile-controls';
        mobileControls.style.cssText = `
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        `;
        
        // Zoom in button
        const zoomInBtn = document.createElement('button');
        zoomInBtn.className = 'zoom-btn';
        zoomInBtn.innerHTML = '+';
        zoomInBtn.style.cssText = `
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(76, 201, 240, 0.8);
            border: none;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        `;
        
        // Zoom out button
        const zoomOutBtn = document.createElement('button');
        zoomOutBtn.className = 'zoom-btn';
        zoomOutBtn.innerHTML = '-';
        zoomOutBtn.style.cssText = `
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(247, 37, 133, 0.8);
            border: none;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        `;
        
        // Reset view button
        const resetBtn = document.createElement('button');
        resetBtn.className = 'reset-btn';
        resetBtn.innerHTML = '⟲';
        resetBtn.style.cssText = `
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(56, 176, 0, 0.8);
            border: none;
            color: white;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        `;
        
        // Add hover effects
        [zoomInBtn, zoomOutBtn, resetBtn].forEach(btn => {
            btn.addEventListener('mouseenter', () => {
                btn.style.transform = 'scale(1.1)';
                btn.style.boxShadow = '0 6px 12px rgba(0, 0, 0, 0.4)';
            });
            btn.addEventListener('mouseleave', () => {
                btn.style.transform = 'scale(1)';
                btn.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
            });
        });
        
        mobileControls.appendChild(zoomInBtn);
        mobileControls.appendChild(zoomOutBtn);
        mobileControls.appendChild(resetBtn);
        container.appendChild(mobileControls);
        
        // Microscope lighting setup
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(5, 10, 7);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        // Simulate microscope illumination
        const spotLight = new THREE.SpotLight(0xaaffaa, 1.0);
        spotLight.position.set(0, 20, 10);
        spotLight.angle = Math.PI / 6;
        spotLight.penumbra = 0.3;
        spotLight.decay = 2;
        spotLight.distance = 50;
        spotLight.castShadow = true;
        scene.add(spotLight);
        
        // Create realistic plant cell environment - larger cell
        // Cell membrane with lipid bilayer
        const membraneGeometry = new THREE.SphereGeometry(40, 64, 64);
        const membraneMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x2d5016,
            metalness: 0.1,
            roughness: 0.8,
            transparent: true,
            opacity: 0.2,
            side: THREE.DoubleSide,
            clearcoat: 0.3,
            clearcoatRoughness: 0.2
        });
        const cellMembrane = new THREE.Mesh(membraneGeometry, membraneMaterial);
        scene.add(cellMembrane);
        
        // Cytoplasm with granular texture
        const cytoplasmGeometry = new THREE.SphereGeometry(38, 64, 64);
        const cytoplasmMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x4a7c59,
            metalness: 0.0,
            roughness: 0.9,
            transparent: true,
            opacity: 0.4,
            side: THREE.DoubleSide
        });
        const cytoplasm = new THREE.Mesh(cytoplasmGeometry, cytoplasmMaterial);
        scene.add(cytoplasm);
        
        // Nucleus with nuclear envelope - larger
        const nucleusGeometry = new THREE.SphereGeometry(12, 32, 32);
        const nucleusMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x6b5b95,
            metalness: 0.1,
            roughness: 0.3,
            transparent: true,
            opacity: 0.6,
            side: THREE.DoubleSide,
            clearcoat: 0.5,
            clearcoatRoughness: 0.1
        });
        const nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
        nucleus.position.set(0, 0, 0);
        scene.add(nucleus);
        
        // Nuclear envelope with pores
        const envelopeGeometry = new THREE.SphereGeometry(12.2, 32, 32);
        const envelopeMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x8b7ab8,
            metalness: 0.2,
            roughness: 0.4,
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide
        });
        const nuclearEnvelope = new THREE.Mesh(envelopeGeometry, envelopeMaterial);
        nuclearEnvelope.position.copy(nucleus.position);
        scene.add(nuclearEnvelope);
        
        // Nuclear pores - more for larger nucleus
        const poreGroup = new THREE.Group();
        for (let i = 0; i < 80; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const radius = 12.2;
            
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);
            
            const poreGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.6, 8);
            const poreMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x9d8cbf,
                metalness: 0.3,
                roughness: 0.2,
                transparent: true,
                opacity: 0.8
            });
            const pore = new THREE.Mesh(poreGeometry, poreMaterial);
            pore.position.set(x, y, z);
            pore.lookAt(0, 0, 0);
            pore.rotateX(Math.PI / 2);
            poreGroup.add(pore);
        }
        scene.add(poreGroup);
        
        // Nucleolus - larger
        const nucleolusGeometry = new THREE.SphereGeometry(4, 32, 32);
        const nucleolusMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x8b7ab8,
            metalness: 0.2,
            roughness: 0.3,
            emissive: 0x8b7ab8,
            emissiveIntensity: 0.2
        });
        const nucleolus = new THREE.Mesh(nucleolusGeometry, nucleolusMaterial);
        nucleolus.position.set(0, 0, 0);
        nucleus.add(nucleolus);
        
        // Chloroplasts with realistic structure - more and larger
        const chloroplastGroup = new THREE.Group();
        for (let i = 0; i < 15; i++) {
            // Outer membrane
            const outerGeometry = new THREE.SphereGeometry(3, 32, 32);
            const outerMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x2e8b57,
                metalness: 0.1,
                roughness: 0.7,
                transparent: true,
                opacity: 0.6
            });
            const outerMembrane = new THREE.Mesh(outerGeometry, outerMaterial);
            
            // Inner membrane
            const innerGeometry = new THREE.SphereGeometry(2.8, 32, 32);
            const innerMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x228b22,
                metalness: 0.1,
                roughness: 0.5,
                transparent: true,
                opacity: 0.7
            });
            const innerMembrane = new THREE.Mesh(innerGeometry, innerMaterial);
            
            // Thylakoid stacks (grana)
            const granaGroup = new THREE.Group();
            for (let j = 0; j < 10; j++) {
                const granumGeometry = new THREE.CylinderGeometry(1, 1, 0.4, 16);
                const granumMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0x006400,
                    metalness: 0.2,
                    roughness: 0.3,
                    emissive: 0x006400,
                    emissiveIntensity: 0.3
                });
                const granum = new THREE.Mesh(granumGeometry, granumMaterial);
                
                // Position in a stack
                granum.position.y = (j - 4.5) * 0.5;
                granum.position.x = (j % 2 === 0) ? 0.7 : -0.7;
                granaGroup.add(granum);
            }
            
            // Combine into chloroplast
            const chloroplast = new THREE.Group();
            chloroplast.add(outerMembrane);
            chloroplast.add(innerMembrane);
            chloroplast.add(granaGroup);
            
            // Position randomly in cell
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const radius = 15 + Math.random() * 15;
            
            chloroplast.position.x = radius * Math.sin(phi) * Math.cos(theta);
            chloroplast.position.y = radius * Math.sin(phi) * Math.sin(theta);
            chloroplast.position.z = radius * Math.cos(phi);
            
            chloroplastGroup.add(chloroplast);
        }
        scene.add(chloroplastGroup);
        
        // Mitochondria with cristae - more and larger
        const mitochondriaGroup = new THREE.Group();
        for (let i = 0; i < 12; i++) {
            const mitochondrionGeometry = new THREE.CylinderGeometry(1.5, 1.5, 4, 32);
            const mitochondrionMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xff6347,
                metalness: 0.2,
                roughness: 0.6,
                transparent: true,
                opacity: 0.7
            });
            const mitochondrion = new THREE.Mesh(mitochondrionGeometry, mitochondrionMaterial);
            
            // Inner membrane with cristae
            for (let j = 0; j < 8; j++) {
                const cristaGeometry = new THREE.PlaneGeometry(1, 3.5);
                const cristaMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0xcd5c5c,
                    metalness: 0.3,
                    roughness: 0.4,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                const crista = new THREE.Mesh(cristaGeometry, cristaMaterial);
                crista.rotation.y = (j / 8) * Math.PI * 2;
                crista.position.x = Math.cos((j / 8) * Math.PI * 2) * 1.0;
                crista.position.z = Math.sin((j / 8) * Math.PI * 2) * 1.0;
                mitochondrion.add(crista);
            }
            
            // Position randomly
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const radius = 12 + Math.random() * 20;
            
            mitochondrion.position.x = radius * Math.sin(phi) * Math.cos(theta);
            mitochondrion.position.y = radius * Math.sin(phi) * Math.sin(theta);
            mitochondrion.position.z = radius * Math.cos(phi);
            
            mitochondrion.rotation.x = Math.random() * Math.PI;
            mitochondrion.rotation.y = Math.random() * Math.PI;
            
            mitochondriaGroup.add(mitochondrion);
        }
        scene.add(mitochondriaGroup);
        
        // Vacuole with tonoplast - larger
        const vacuoleGeometry = new THREE.SphereGeometry(15, 32, 32);
        const vacuoleMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x90ee90,
            metalness: 0.0,
            roughness: 0.9,
            transparent: true,
            opacity: 0.2,
            side: THREE.DoubleSide
        });
        const vacuole = new THREE.Mesh(vacuoleGeometry, vacuoleMaterial);
        vacuole.position.set(-20, -10, -10);
        scene.add(vacuole);
        
        // Tonoplast (vacuole membrane)
        const tonoplastGeometry = new THREE.SphereGeometry(15.1, 32, 32);
        const tonoplastMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x228b22,
            metalness: 0.1,
            roughness: 0.7,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const tonoplast = new THREE.Mesh(tonoplastGeometry, tonoplastMaterial);
        tonoplast.position.copy(vacuole.position);
        scene.add(tonoplast);
        
        // Endoplasmic reticulum - more extensive
        const erGroup = new THREE.Group();
        for (let i = 0; i < 10; i++) {
            const erCurve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(-15, i * 4 - 15, -15),
                new THREE.Vector3(0, i * 4 - 15, 0),
                new THREE.Vector3(15, i * 4 - 15, 15),
                new THREE.Vector3(0, i * 4 - 15, 0)
            ]);
            
            const erGeometry = new THREE.TubeGeometry(erCurve, 50, 0.4, 8, false);
            const erMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x9370db,
                metalness: 0.2,
                roughness: 0.5,
                transparent: true,
                opacity: 0.6
            });
            const er = new THREE.Mesh(erGeometry, erMaterial);
            erGroup.add(er);
        }
        scene.add(erGroup);
        
        // Golgi apparatus - new addition
        const golgiGroup = new THREE.Group();
        for (let i = 0; i < 5; i++) {
            const cisternaGeometry = new THREE.CylinderGeometry(3, 3, 0.3, 32);
            const cisternaMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xda70d6,
                metalness: 0.2,
                roughness: 0.5,
                transparent: true,
                opacity: 0.7
            });
            const cisterna = new THREE.Mesh(cisternaGeometry, cisternaMaterial);
            cisterna.position.set(15, i * 0.5 - 1, 0);
            cisterna.rotation.x = Math.PI / 2;
            golgiGroup.add(cisterna);
        }
        scene.add(golgiGroup);
        
        // Ribosomes - more
        const ribosomeGroup = new THREE.Group();
        for (let i = 0; i < 150; i++) {
            const ribosomeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const ribosomeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xdaa520,
                metalness: 0.3,
                roughness: 0.2,
                emissive: 0xdaa520,
                emissiveIntensity: 0.4
            });
            const ribosome = new THREE.Mesh(ribosomeGeometry, ribosomeMaterial);
            
            // Position randomly in cell
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const radius = 5 + Math.random() * 30;
            
            ribosome.position.x = radius * Math.sin(phi) * Math.cos(theta);
            ribosome.position.y = radius * Math.sin(phi) * Math.sin(theta);
            ribosome.position.z = radius * Math.cos(phi);
            
            ribosomeGroup.add(ribosome);
        }
        scene.add(ribosomeGroup);
        
        // Peroxisomes - new addition
        const peroxisomeGroup = new THREE.Group();
        for (let i = 0; i < 8; i++) {
            const peroxisomeGeometry = new THREE.SphereGeometry(1.2, 16, 16);
            const peroxisomeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xff8c00,
                metalness: 0.2,
                roughness: 0.5,
                transparent: true,
                opacity: 0.7
            });
            const peroxisome = new THREE.Mesh(peroxisomeGeometry, peroxisomeMaterial);
            
            // Position randomly
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const radius = 10 + Math.random() * 20;
            
            peroxisome.position.x = radius * Math.sin(phi) * Math.cos(theta);
            peroxisome.position.y = radius * Math.sin(phi) * Math.sin(theta);
            peroxisome.position.z = radius * Math.cos(phi);
            
            peroxisomeGroup.add(peroxisome);
        }
        scene.add(peroxisomeGroup);
        
        // Cytoskeleton - new addition (microtubules)
        const cytoskeletonGroup = new THREE.Group();
        for (let i = 0; i < 20; i++) {
            const startTheta = Math.random() * Math.PI * 2;
            const startPhi = Math.random() * Math.PI;
            const startRadius = 5;
            
            const startX = startRadius * Math.sin(startPhi) * Math.cos(startTheta);
            const startY = startRadius * Math.sin(startPhi) * Math.sin(startTheta);
            const startZ = startRadius * Math.cos(startPhi);
            
            const endTheta = startTheta + (Math.random() - 0.5) * Math.PI;
            const endPhi = startPhi + (Math.random() - 0.5) * Math.PI / 2;
            const endRadius = 30;
            
            const endX = endRadius * Math.sin(endPhi) * Math.cos(endTheta);
            const endY = endRadius * Math.sin(endPhi) * Math.sin(endTheta);
            const endZ = endRadius * Math.cos(endPhi);
            
            const microtubuleCurve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(startX, startY, startZ),
                new THREE.Vector3((startX + endX) / 2, (startY + endY) / 2, (startZ + endZ) / 2),
                new THREE.Vector3(endX, endY, endZ)
            ]);
            
            const microtubuleGeometry = new THREE.TubeGeometry(microtubuleCurve, 20, 0.05, 4, false);
            const microtubuleMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.3,
                roughness: 0.2,
                transparent: true,
                opacity: 0.6
            });
            const microtubule = new THREE.Mesh(microtubuleGeometry, microtubuleMaterial);
            cytoskeletonGroup.add(microtubule);
        }
        scene.add(cytoskeletonGroup);
        
        // Cytoplasmic streaming particles - more
        const streamingGeometry = new THREE.BufferGeometry();
        const streamingCount = 1500;
        const streamingPositions = new Float32Array(streamingCount * 3);
        const streamingVelocities = [];
        
        for (let i = 0; i < streamingCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const radius = 5 + Math.random() * 30;
            
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);
            
            streamingPositions[i * 3] = x;
            streamingPositions[i * 3 + 1] = y;
            streamingPositions[i * 3 + 2] = z;
            
            // Random velocity for streaming effect
            streamingVelocities.push({
                x: (Math.random() - 0.5) * 0.03,
                y: (Math.random() - 0.5) * 0.03,
                z: (Math.random() - 0.5) * 0.03
            });
        }
        
        streamingGeometry.setAttribute('position', new THREE.BufferAttribute(streamingPositions, 3));
        const streamingMaterial = new THREE.PointsMaterial({
            color: 0x90ee90,
            size: 0.1,
            transparent: true,
            opacity: 0.7,
            blending: THREE.AdditiveBlending
        });
        
        const streamingParticles = new THREE.Points(streamingGeometry, streamingMaterial);
        scene.add(streamingParticles);
        
        // DNA Helix Parameters (inside nucleus) - larger
        const basePairs = 40;
        const helixRadius = 2;
        const helixHeight = 0.3;
        const backboneRadius = 0.1;
        const basePairWidth = 0.15;
        const basePairHeight = 0.05;
        
        // Nucleotide materials with advanced properties
        const nucleotideMaterials = {
            'A': new THREE.MeshPhysicalMaterial({
                color: 0xff0000,
                metalness: 0.2,
                roughness: 0.3,
                transparent: true,
                opacity: 0.9,
                emissive: 0x440000,
                emissiveIntensity: 0.4
            }),
            'T': new THREE.MeshPhysicalMaterial({
                color: 0x00ff00,
                metalness: 0.2,
                roughness: 0.3,
                transparent: true,
                opacity: 0.9,
                emissive: 0x004400,
                emissiveIntensity: 0.4
            }),
            'G': new THREE.MeshPhysicalMaterial({
                color: 0x0000ff,
                metalness: 0.2,
                roughness: 0.3,
                transparent: true,
                opacity: 0.9,
                emissive: 0x000044,
                emissiveIntensity: 0.4
            }),
            'C': new THREE.MeshPhysicalMaterial({
                color: 0xffff00,
                metalness: 0.2,
                roughness: 0.3,
                transparent: true,
                opacity: 0.9,
                emissive: 0x444400,
                emissiveIntensity: 0.4
            })
        };
        
        // Create DNA group inside nucleus
        const dnaGroup = new THREE.Group();
        nucleus.add(dnaGroup);
        
        // Create DNA backbones with enhanced geometry
        const backboneCurve1 = new THREE.CatmullRomCurve3([]);
        const backboneCurve2 = new THREE.CatmullRomCurve3([]);
        
        for (let i = 0; i <= basePairs; i++) {
            const angle = (i / basePairs) * Math.PI * 4;
            const y = (i - basePairs / 2) * helixHeight;
            
            const x1 = Math.cos(angle) * helixRadius;
            const z1 = Math.sin(angle) * helixRadius;
            backboneCurve1.points.push(new THREE.Vector3(x1, y, z1));
            
            const x2 = Math.cos(angle + Math.PI) * helixRadius;
            const z2 = Math.sin(angle + Math.PI) * helixRadius;
            backboneCurve2.points.push(new THREE.Vector3(x2, y, z2));
        }
        
        const backboneGeometry1 = new THREE.TubeGeometry(backboneCurve1, 200, backboneRadius, 16, false);
        const backboneGeometry2 = new THREE.TubeGeometry(backboneCurve2, 200, backboneRadius, 16, false);
        
        const backboneMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            metalness: 0.3,
            roughness: 0.2,
            transparent: true,
            opacity: 0.9,
            emissive: 0x222222,
            emissiveIntensity: 0.3
        });
        
        const backbone1 = new THREE.Mesh(backboneGeometry1, backboneMaterial);
        const backbone2 = new THREE.Mesh(backboneGeometry2, backboneMaterial);
        backbone1.castShadow = true;
        backbone2.castShadow = true;
        dnaGroup.add(backbone1, backbone2);
        
        // Generate DNA sequence
        const bases = ['A', 'T', 'G', 'C'];
        const sequence = [];
        for (let i = 0; i < basePairs; i++) {
            const base = bases[Math.floor(Math.random() * bases.length)];
            sequence.push(base);
        }
        
        // Create base pairs with detailed geometry
        for (let i = 0; i < basePairs; i++) {
            const angle = (i / basePairs) * Math.PI * 4;
            const y = (i - basePairs / 2) * helixHeight;
            
            const x1 = Math.cos(angle) * helixRadius;
            const z1 = Math.sin(angle) * helixRadius;
            const x2 = Math.cos(angle + Math.PI) * helixRadius;
            const z2 = Math.sin(angle + Math.PI) * helixRadius;
            
            // Create base pair group
            const basePairGroup = new THREE.Group();
            
            // Nucleotide spheres with enhanced geometry
            const base = sequence[i];
            const nucleotideGeometry = new THREE.SphereGeometry(0.2, 32, 32);
            const nucleotide1 = new THREE.Mesh(nucleotideGeometry, nucleotideMaterials[base]);
            nucleotide1.position.set(x1, y, z1);
            nucleotide1.castShadow = true;
            nucleotide1.userData = { type: 'nucleotide', base: base, position: i };
            basePairGroup.add(nucleotide1);
            
            const complementaryBase = base === 'A' ? 'T' : base === 'T' ? 'A' : base === 'G' ? 'C' : 'G';
            const nucleotide2 = new THREE.Mesh(nucleotideGeometry, nucleotideMaterials[complementaryBase]);
            nucleotide2.position.set(x2, y, z2);
            nucleotide2.castShadow = true;
            nucleotide2.userData = { type: 'nucleotide', base: complementaryBase, position: i };
            basePairGroup.add(nucleotide2);
            
            // Connector between nucleotides
            const connectorGeometry = new THREE.CylinderGeometry(0.05, 0.05, 
                Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(z2 - z1, 2)), 16);
            const connectorMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.3,
                roughness: 0.2,
                transparent: true,
                opacity: 0.8
            });
            
            const connector = new THREE.Mesh(connectorGeometry, connectorMaterial);
            connector.position.set((x1 + x2) / 2, y, (z1 + z2) / 2);
            connector.rotation.z = Math.PI / 2;
            connector.rotation.y = Math.atan2(z2 - z1, x2 - x1);
            basePairGroup.add(connector);
            
            // Add hydrogen bonds
            if (i % 2 === 0) {
                const bondGeometry = new THREE.CylinderGeometry(0.02, 0.02, 
                    Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(z2 - z1, 2)) * 0.8, 8);
                const bondMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.5
                });
                
                const bond = new THREE.Mesh(bondGeometry, bondMaterial);
                bond.position.set((x1 + x2) / 2, y, (z1 + z2) / 2);
                bond.rotation.z = Math.PI / 2;
                bond.rotation.y = Math.atan2(z2 - z1, x2 - x1);
                basePairGroup.add(bond);
            }
            
            dnaGroup.add(basePairGroup);
        }
        
        // Add sugar-phosphate groups
        for (let i = 0; i < basePairs; i += 2) {
            const angle = (i / basePairs) * Math.PI * 4;
            const y = (i - basePairs / 2) * helixHeight;
            const x = Math.cos(angle) * helixRadius;
            const z = Math.sin(angle) * helixRadius;
            
            // Sugar molecule
            const sugarGeometry = new THREE.IcosahedronGeometry(0.15, 1);
            const sugarMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffd166,
                metalness: 0.3,
                roughness: 0.2,
                transparent: true,
                opacity: 0.9,
                emissive: 0x443311,
                emissiveIntensity: 0.4
            });
            
            const sugar = new THREE.Mesh(sugarGeometry, sugarMaterial);
            sugar.position.set(x, y, z);
            sugar.castShadow = true;
            sugar.userData = { type: 'sugar', position: i };
            dnaGroup.add(sugar);
            
            // Phosphate group
            const phosphateAngle = angle + Math.PI / 8;
            const phosphateX = Math.cos(phosphateAngle) * (helixRadius + 0.3);
            const phosphateZ = Math.sin(phosphateAngle) * (helixRadius + 0.3);
            
            const phosphateGeometry = new THREE.OctahedronGeometry(0.18, 0);
            const phosphateMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xef476f,
                metalness: 0.3,
                roughness: 0.2,
                transparent: true,
                opacity: 0.9,
                emissive: 0x441122,
                emissiveIntensity: 0.5
            });
            
            const phosphate = new THREE.Mesh(phosphateGeometry, phosphateMaterial);
            phosphate.position.set(phosphateX, y, phosphateZ);
            phosphate.castShadow = true;
            phosphate.userData = { type: 'phosphate', position: i };
            dnaGroup.add(phosphate);
            
            // Connect sugar and phosphate
            const bondGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
            const bondMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.3,
                roughness: 0.2,
                transparent: true,
                opacity: 0.8
            });
            const bond = new THREE.Mesh(bondGeometry, bondMaterial);
            bond.position.set((x + phosphateX) / 2, y, (z + phosphateZ) / 2);
            bond.lookAt(phosphateX, y, phosphateZ);
            bond.rotateX(Math.PI / 2);
            dnaGroup.add(bond);
        }
        
        // Interactive features
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredObject = null;
        let focusedElement = null;
        let cameraAnimating = false;
        let cameraProgress = 0;
        
        // Camera path for animation - further out
        const cameraPath = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0, 0, 60),
            new THREE.Vector3(40, 20, 40),
            new THREE.Vector3(0, 40, 30),
            new THREE.Vector3(-40, 20, 40),
            new THREE.Vector3(0, 0, 60)
        ]);
        
        function onMouseMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }
        
        function onMouseClick(event) {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(dnaGroup.children, true);
            
            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (object.userData.type) {
                    focusOnElement(object);
                }
            }
        }
        
        function focusOnElement(element) {
            focusedElement = element;
            cameraAnimating = true;
            cameraProgress = 0;
            
            // Highlight the focused element
            if (focusedElement) {
                focusedElement.material.emissiveIntensity = 1.0;
            }
        }
        
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('click', onMouseClick);
        
        // Add controls with extended zoom range
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 0.01; // No zoom-in limit
        controls.maxDistance = 100; // Increased zoom-out limit
        
        // Mobile zoom controls
        const zoomSpeed = 5;
        
        zoomInBtn.addEventListener('click', () => {
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            camera.position.addScaledVector(direction, -zoomSpeed);
        });
        
        zoomOutBtn.addEventListener('click', () => {
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            camera.position.addScaledVector(direction, zoomSpeed);
        });
        
        resetBtn.addEventListener('click', () => {
            camera.position.set(0, 0, 60);
            controls.target.set(0, 0, 0);
            controls.update();
        });
        
        // Touch controls for mobile
        let touchStartDistance = 0;
        
        renderer.domElement.addEventListener('touchstart', (event) => {
            if (event.touches.length === 2) {
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                touchStartDistance = Math.sqrt(dx * dx + dy * dy);
            }
        });
        
        renderer.domElement.addEventListener('touchmove', (event) => {
            if (event.touches.length === 2) {
                event.preventDefault();
                
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const touchDistance = Math.sqrt(dx * dx + dy * dy);
                
                if (touchStartDistance > 0) {
                    const scale = touchDistance / touchStartDistance;
                    const direction = new THREE.Vector3();
                    camera.getWorldDirection(direction);
                    
                    if (scale < 1) {
                        // Zoom in
                        camera.position.addScaledVector(direction, -zoomSpeed * (1 - scale));
                    } else {
                        // Zoom out
                        camera.position.addScaledVector(direction, zoomSpeed * (scale - 1));
                    }
                    
                    touchStartDistance = touchDistance;
                }
            }
        });
        
        // Animation
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            
            const elapsedTime = clock.getElapsedTime();
            
            // Rotate DNA structure
            dnaGroup.rotation.y = elapsedTime * 0.5;
            
            // Animate organelles
            chloroplastGroup.rotation.y = elapsedTime * 0.02;
            mitochondriaGroup.rotation.y = elapsedTime * 0.03;
            erGroup.rotation.y = elapsedTime * 0.01;
            ribosomeGroup.rotation.y = elapsedTime * 0.005;
            peroxisomeGroup.rotation.y = elapsedTime * 0.015;
            cytoskeletonGroup.rotation.y = elapsedTime * 0.008;
            
            // Animate cytoplasmic streaming
            const positions = streamingParticles.geometry.attributes.position.array;
            for (let i = 0; i < streamingCount; i++) {
                const idx = i * 3;
                positions[idx] += streamingVelocities[i].x;
                positions[idx + 1] += streamingVelocities[i].y;
                positions[idx + 2] += streamingVelocities[i].z;
                
                // Boundary check - keep particles within cell
                const dist = Math.sqrt(
                    positions[idx] * positions[idx] + 
                    positions[idx + 1] * positions[idx + 1] + 
                    positions[idx + 2] * positions[idx + 2]
                );
                
                if (dist > 38) {
                    // Reverse direction if hitting boundary
                    streamingVelocities[i].x *= -1;
                    streamingVelocities[i].y *= -1;
                    streamingVelocities[i].z *= -1;
                }
            }
            streamingParticles.geometry.attributes.position.needsUpdate = true;
            
            // Camera animation
            if (cameraAnimating) {
                cameraProgress += 0.02;
                
                if (cameraProgress >= 1) {
                    cameraAnimating = false;
                    cameraProgress = 1;
                }
                
                if (focusedElement) {
                    // Focus on specific element
                    const targetPosition = focusedElement.getWorldPosition(new THREE.Vector3());
                    const offset = new THREE.Vector3(0, 0, 3);
                    offset.applyQuaternion(camera.quaternion);
                    
                    camera.position.lerpVectors(
                        camera.position,
                        targetPosition.clone().add(offset),
                        cameraProgress
                    );
                    
                    controls.target.lerp(targetPosition, cameraProgress);
                } else {
                    // Follow camera path
                    const pathPosition = cameraPath.getPoint(cameraProgress);
                    camera.position.lerp(pathPosition, 0.1);
                    
                    const lookAtPosition = new THREE.Vector3(0, 0, 0);
                    controls.target.lerp(lookAtPosition, 0.1);
                }
            }
            
            // Handle hover effects
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(dnaGroup.children, true);
            
            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (object.userData.type && hoveredObject !== object) {
                    if (hoveredObject) {
                        hoveredObject.scale.set(1, 1, 1);
                    }
                    hoveredObject = object;
                    object.scale.set(1.3, 1.3, 1.3);
                }
            } else if (hoveredObject) {
                hoveredObject.scale.set(1, 1, 1);
                hoveredObject = null;
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Handle resize
        const handleResize = debounce(() => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }, 250);
        
        window.addEventListener('resize', handleResize);
        
        // Store reference with enhanced cleanup
        state.charts.species3d = {
            scene, camera, renderer, controls,
            cleanup: () => {
                window.removeEventListener('resize', handleResize);
                renderer.domElement.removeEventListener('mousemove', onMouseMove);
                renderer.domElement.removeEventListener('click', onMouseClick);
                container.removeChild(mobileControls);
                renderer.dispose();
                container.removeChild(renderer.domElement);
            }
        };
        
        state.components.charts.species3d = true;
    } catch (error) {
        console.error('Error initializing 3D species chart:', error);
        document.getElementById('species3d-loading').innerHTML = '<div class="text-center p-4">Error loading 3D chart. Please refresh the page.</div>';
    }
}

// Simple debounce function
function debounce(func, wait) {
    let timeout;
    return function() {
        const context = this;
        const args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
    };
}

// Auto-initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init3DSpeciesChart);
} else {
    // DOM already loaded, run immediately
    init3DSpeciesChart();
}






function init3DSpeciesModel() {
    if (state.components.species3dModel) return;
    
    const container = document.getElementById('species3dModel');
    if (!container) return;
    
    try {
        document.getElementById('species3d-model-loading').style.display = 'none';
        
        // Create professional 3D scene
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0xcccccc, 10, 100);
        
        // Professional camera setup
        const camera = new THREE.PerspectiveCamera(
            45, 
            container.clientWidth / container.clientHeight, 
            0.1, 
            1000
        );
        camera.position.set(0, 3, 15);
        camera.lookAt(0, 1, 0);
        
        // Professional renderer with advanced settings
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);
        
        // Professional lighting setup
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
        mainLight.position.set(5, 10, 7);
        mainLight.castShadow = true;
        mainLight.shadow.camera.near = 0.1;
        mainLight.shadow.camera.far = 50;
        mainLight.shadow.camera.left = -10;
        mainLight.shadow.camera.right = 10;
        mainLight.shadow.camera.top = 10;
        mainLight.shadow.camera.bottom = -10;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        scene.add(mainLight);
        
        // Add rim light for professional look
        const rimLight = new THREE.DirectionalLight(0x8bb7ff, 0.3);
        rimLight.position.set(-5, 3, -5);
        scene.add(rimLight);
        
        // Load textures with proper error handling
        const textureLoader = new THREE.TextureLoader();
        const loadingManager = new THREE.LoadingManager();
        
        // Define texture paths (in a real app, these would be actual image files)
        const texturePaths = {
            // Rose textures
            rose: {
                petalColor: '/textures/rose/petal-color.jpg',
                petalNormal: '/textures/rose/petal-normal.jpg',
                petalRoughness: '/textures/rose/petal-roughness.jpg',
                stemColor: '/textures/rose/stem-color.jpg',
                stemNormal: '/textures/rose/stem-normal.jpg',
                leafColor: '/textures/rose/leaf-color.jpg',
                leafNormal: '/textures/rose/leaf-normal.jpg',
                centerColor: '/textures/rose/center-color.jpg',
                centerNormal: '/textures/rose/center-normal.jpg'
            },
            // Tulip textures
            tulip: {
                petalColor: '/textures/tulip/petal-color.jpg',
                petalNormal: '/textures/tulip/petal-normal.jpg',
                petalRoughness: '/textures/tulip/petal-roughness.jpg',
                stemColor: '/textures/tulip/stem-color.jpg',
                stemNormal: '/textures/tulip/stem-normal.jpg',
                leafColor: '/textures/tulip/leaf-color.jpg',
                leafNormal: '/textures/tulip/leaf-normal.jpg',
                centerColor: '/textures/tulip/center-color.jpg',
                centerNormal: '/textures/tulip/center-normal.jpg'
            },
            // Orchid textures
            orchid: {
                petalColor: '/textures/orchid/petal-color.jpg',
                petalNormal: '/textures/orchid/petal-normal.jpg',
                petalRoughness: '/textures/orchid/petal-roughness.jpg',
                stemColor: '/textures/orchid/stem-color.jpg',
                stemNormal: '/textures/orchid/stem-normal.jpg',
                leafColor: '/textures/orchid/leaf-color.jpg',
                leafNormal: '/textures/orchid/leaf-normal.jpg',
                centerColor: '/textures/orchid/center-color.jpg',
                centerNormal: '/textures/orchid/center-normal.jpg'
            },
            // Sunflower textures
            sunflower: {
                petalColor: '/textures/sunflower/petal-color.jpg',
                petalNormal: '/textures/sunflower/petal-normal.jpg',
                petalRoughness: '/textures/sunflower/petal-roughness.jpg',
                stemColor: '/textures/sunflower/stem-color.jpg',
                stemNormal: '/textures/sunflower/stem-normal.jpg',
                leafColor: '/textures/sunflower/leaf-color.jpg',
                leafNormal: '/textures/sunflower/leaf-normal.jpg',
                centerColor: '/textures/sunflower/center-color.jpg',
                centerNormal: '/textures/sunflower/center-normal.jpg'
            }
        };
        
        // Create environment with realistic ground
        createRealisticEnvironment(scene, textureLoader);
        
        // Create professional flower model
        const flowerGroup = createProfessionalFlower(scene, textureLoader, texturePaths.rose);
        scene.add(flowerGroup);
        
        // Add post-processing effects
        const composer = createPostProcessing(renderer, scene, camera);
        
        // Add professional controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;
        controls.maxDistance = 30;
        controls.maxPolarAngle = Math.PI / 2;
        
        // Animation system
        const clock = new THREE.Clock();
        let windStrength = 0;
        let time = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            time += delta;
            
            // Dynamic wind simulation
            windStrength = Math.sin(time * 0.2) * 0.3 + 0.3;
            
            // Animate flower with wind effect
            animateProfessionalFlower(flowerGroup, time, windStrength);
            
            // Update controls
            controls.update();
            
            // Render with post-processing
            composer.render();
        }
        
        animate();
        
        // Handle resize with professional responsiveness
        const handleResize = debounce(() => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            composer.setSize(container.clientWidth, container.clientHeight);
        }, 250);
        
        window.addEventListener('resize', handleResize);
        
        // Interactive species changing
        let currentSpecies = 'rose';
        let currentTextures = texturePaths.rose;
        
        // Store reference with professional capabilities
        state.species3dModel = {
            scene, camera, renderer, controls, flowerGroup, composer,
            cleanup: () => {
                window.removeEventListener('resize', handleResize);
                renderer.dispose();
                container.removeChild(renderer.domElement);
            },
            loadModel: (species) => {
                // Professional species loading
                showToast(`Loading professional ${species} model...`, 'info');
                
                // Update species
                currentSpecies = species;
                currentTextures = texturePaths[species];
                
                // Change flower appearance based on species with real textures
                updateProfessionalFlower(flowerGroup, currentTextures);
                
                // Update environment based on species
                updateProfessionalEnvironment(scene, species);
            },
            // New professional methods
            setWindStrength: (strength) => {
                windStrength = Math.max(0, Math.min(1, strength));
            },
            setTimeOfDay: (timeOfDay) => {
                // 'dawn', 'day', 'dusk', 'night'
                updateProfessionalLighting(scene, timeOfDay);
            },
            setSeason: (season) => {
                // 'spring', 'summer', 'autumn', 'winter'
                updateProfessionalSeason(scene, season);
            },
            setCameraPreset: (preset) => {
                // 'closeup', 'medium', 'wide', 'top'
                updateCameraPreset(camera, preset);
            }
        };
        
        state.components.species3dModel = true;
    } catch (error) {
        console.error('Error initializing professional 3D species model:', error);
        document.getElementById('species3d-model-loading').innerHTML = 
            '<div class="text-center p-4">Error loading professional 3D model. Please refresh the page.</div>';
    }
}

// Helper function to create realistic environment
function createRealisticEnvironment(scene, textureLoader) {
    // Create ground with realistic grass texture
    const groundGeometry = new THREE.PlaneGeometry(50, 50, 50, 50);
    
    // Load ground textures
    const groundColorTexture = textureLoader.load('/textures/ground/grass-color.jpg');
    const groundNormalTexture = textureLoader.load('/textures/ground/grass-normal.jpg');
    const groundRoughnessTexture = textureLoader.load('/textures/ground/grass-roughness.jpg');
    const groundAOTTexture = textureLoader.load('/textures/ground/grass-ao.jpg');
    
    // Set texture wrapping and repeat
    groundColorTexture.wrapS = groundColorTexture.wrapT = THREE.RepeatWrapping;
    groundColorTexture.repeat.set(20, 20);
    groundNormalTexture.wrapS = groundNormalTexture.wrapT = THREE.RepeatWrapping;
    groundNormalTexture.repeat.set(20, 20);
    groundRoughnessTexture.wrapS = groundRoughnessTexture.wrapT = THREE.RepeatWrapping;
    groundRoughnessTexture.repeat.set(20, 20);
    groundAOTTexture.wrapS = groundAOTTexture.wrapT = THREE.RepeatWrapping;
    groundAOTTexture.repeat.set(20, 20);
    
    // Add height variation to ground
    const vertices = groundGeometry.attributes.position.array;
    for (let i = 0; i < vertices.length; i += 3) {
        vertices[i + 2] = Math.random() * 0.5;
    }
    groundGeometry.computeVertexNormals();
    
    const groundMaterial = new THREE.MeshStandardMaterial({
        map: groundColorTexture,
        normalMap: groundNormalTexture,
        roughnessMap: groundRoughnessTexture,
        aoMap: groundAOTTexture,
        roughness: 0.8,
        metalness: 0.1
    });
    
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -1.5;
    ground.receiveShadow = true;
    scene.add(ground);
    
    // Add realistic sky with HDRI
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();
    
    const hdriTexture = textureLoader.load(
        '/textures/environment/sky-hdri.jpg',
        (texture) => {
            const envMap = pmremGenerator.fromEquirectangular(texture).texture;
            scene.environment = envMap;
            scene.background = envMap;
            texture.dispose();
            pmremGenerator.dispose();
        }
    );
    
    // Add detailed trees in background
    for (let i = 0; i < 10; i++) {
        const tree = createRealisticTree(textureLoader);
        tree.position.set(
            Math.random() * 40 - 20,
            -1.5,
            Math.random() * 40 - 20
        );
        tree.scale.set(
            2 + Math.random() * 2,
            2 + Math.random() * 2,
            2 + Math.random() * 2
        );
        scene.add(tree);
    }
    
    // Add rocks with realistic textures
    for (let i = 0; i < 15; i++) {
        const rock = createRealisticRock(textureLoader);
        rock.position.set(
            Math.random() * 30 - 15,
            -1.4,
            Math.random() * 30 - 15
        );
        rock.scale.set(
            0.5 + Math.random() * 1,
            0.5 + Math.random() * 1,
            0.5 + Math.random() * 1
        );
        scene.add(rock);
    }
}

// Helper function to create professional flower
function createProfessionalFlower(scene, textureLoader, textures) {
    const flowerGroup = new THREE.Group();
    
    // Load textures
    const stemColorTexture = textureLoader.load(textures.stemColor);
    const stemNormalTexture = textureLoader.load(textures.stemNormal);
    const stemRoughnessTexture = textureLoader.load('/textures/common/stem-roughness.jpg');
    
    const leafColorTexture = textureLoader.load(textures.leafColor);
    const leafNormalTexture = textureLoader.load(textures.leafNormal);
    const leafRoughnessTexture = textureLoader.load('/textures/common/leaf-roughness.jpg');
    
    const petalColorTexture = textureLoader.load(textures.petalColor);
    const petalNormalTexture = textureLoader.load(textures.petalNormal);
    const petalRoughnessTexture = textureLoader.load(textures.petalRoughness);
    
    const centerColorTexture = textureLoader.load(textures.centerColor);
    const centerNormalTexture = textureLoader.load(textures.centerNormal);
    const centerRoughnessTexture = textureLoader.load('/textures/common/center-roughness.jpg');
    
    // Create detailed stem with organic shape
    const stemCurve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(0, -1.5, 0),
        new THREE.Vector3(0.1, -1, 0),
        new THREE.Vector3(-0.1, -0.5, 0),
        new THREE.Vector3(0, 0, 0)
    ]);
    
    const stemGeometry = new THREE.TubeGeometry(stemCurve, 20, 0.08, 8, false);
    const stemMaterial = new THREE.MeshStandardMaterial({
        map: stemColorTexture,
        normalMap: stemNormalTexture,
        roughnessMap: stemRoughnessTexture,
        roughness: 0.8,
        metalness: 0.1
    });
    const stem = new THREE.Mesh(stemGeometry, stemMaterial);
    stem.castShadow = true;
    flowerGroup.add(stem);
    
    // Add leaves to stem
    for (let i = 0; i < 5; i++) {
        const leaf = createRealisticLeaf(textureLoader, leafColorTexture, leafNormalTexture, leafRoughnessTexture);
        const t = i / 5;
        const point = stemCurve.getPoint(t);
        leaf.position.copy(point);
        leaf.rotation.z = Math.PI / 4 + (i % 2 === 0 ? 0.5 : -0.5);
        leaf.scale.set(0.3, 0.3, 0.3);
        flowerGroup.add(leaf);
    }
    
    // Create professional petals
    const petalGroup = new THREE.Group();
    
    // Inner petals
    for (let i = 0; i < 8; i++) {
        const petal = createRealisticPetal(
            textureLoader, 
            petalColorTexture, 
            petalNormalTexture, 
            petalRoughnessTexture,
            0.8
        );
        const angle = (i / 8) * Math.PI * 2;
        petal.position.set(
            Math.cos(angle) * 0.6,
            0.5,
            Math.sin(angle) * 0.6
        );
        petal.rotation.y = angle;
        petal.rotation.z = Math.PI / 6;
        petalGroup.add(petal);
    }
    
    // Outer petals
    for (let i = 0; i < 12; i++) {
        const petal = createRealisticPetal(
            textureLoader, 
            petalColorTexture, 
            petalNormalTexture, 
            petalRoughnessTexture,
            1.0
        );
        const angle = (i / 12) * Math.PI * 2;
        petal.position.set(
            Math.cos(angle) * 1.0,
            0.5,
            Math.sin(angle) * 1.0
        );
        petal.rotation.y = angle;
        petal.rotation.z = Math.PI / 8;
        petalGroup.add(petal);
    }
    
    flowerGroup.add(petalGroup);
    
    // Create professional center
    const centerGroup = new THREE.Group();
    
    // Main center
    const centerGeometry = new THREE.SphereGeometry(0.4, 32, 32);
    const centerMaterial = new THREE.MeshStandardMaterial({
        map: centerColorTexture,
        normalMap: centerNormalTexture,
        roughnessMap: centerRoughnessTexture,
        roughness: 0.6,
        metalness: 0.1
    });
    const center = new THREE.Mesh(centerGeometry, centerMaterial);
    center.position.y = 0.5;
    center.castShadow = true;
    centerGroup.add(center);
    
    // Add pollen grains with realistic texture
    const pollenColorTexture = textureLoader.load('/textures/common/pollen-color.jpg');
    const pollenNormalTexture = textureLoader.load('/textures/common/pollen-normal.jpg');
    
    for (let i = 0; i < 200; i++) {
        const pollenGeometry = new THREE.SphereGeometry(0.02, 8, 8);
        const pollenMaterial = new THREE.MeshStandardMaterial({
            map: pollenColorTexture,
            normalMap: pollenNormalTexture,
            roughness: 0.8,
            metalness: 0.1
        });
        const pollen = new THREE.Mesh(pollenGeometry, pollenMaterial);
        
        // Position pollen on center surface
        const phi = Math.random() * Math.PI;
        const theta = Math.random() * Math.PI * 2;
        const radius = 0.4;
        
        pollen.position.set(
            radius * Math.sin(phi) * Math.cos(theta),
            radius * Math.cos(phi) + 0.5,
            radius * Math.sin(phi) * Math.sin(theta)
        );
        
        centerGroup.add(pollen);
    }
    
    flowerGroup.add(centerGroup);
    
    // Add water droplets with realistic material
    for (let i = 0; i < 30; i++) {
        const droplet = createRealisticWaterDroplet();
        droplet.position.set(
            (Math.random() - 0.5) * 2,
            0.5 + Math.random() * 0.2,
            (Math.random() - 0.5) * 2
        );
        flowerGroup.add(droplet);
    }
    
    return flowerGroup;
}

// Helper function to create realistic petal
function createRealisticPetal(textureLoader, colorTexture, normalTexture, roughnessTexture, size) {
    const petalGroup = new THREE.Group();
    
    // Create petal shape with more detail
    const petalShape = new THREE.Shape();
    petalShape.moveTo(0, 0);
    petalShape.bezierCurveTo(0.2, 0.2, 0.4, 0.8, 0, 1.2);
    petalShape.bezierCurveTo(-0.4, 0.8, -0.2, 0.2, 0, 0);
    
    // Extrude petal shape with more detail
    const extrudeSettings = {
        depth: 0.05,
        bevelEnabled: true,
        bevelThickness: 0.02,
        bevelSize: 0.02,
        bevelSegments: 5
    };
    
    const petalGeometry = new THREE.ExtrudeGeometry(petalShape, extrudeSettings);
    
    // Apply UV mapping to the petal
    petalGeometry.computeBoundingBox();
    const max = petalGeometry.boundingBox.max;
    const min = petalGeometry.boundingBox.min;
    const offset = new THREE.Vector2(0 - min.x, 0 - min.y);
    const range = new THREE.Vector2(max.x - min.x, max.y - min.y);
    const faces = petalGeometry.attributes.position.array.length / 3;
    
    const uvs = new Float32Array(faces * 2);
    
    for (let i = 0; i < faces; i++) {
        uvs[i * 2] = (petalGeometry.attributes.position.array[i * 3] + offset.x) / range.x;
        uvs[i * 2 + 1] = (petalGeometry.attributes.position.array[i * 3 + 1] + offset.y) / range.y;
    }
    
    petalGeometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
    
    const petalMaterial = new THREE.MeshStandardMaterial({
        map: colorTexture,
        normalMap: normalTexture,
        roughnessMap: roughnessTexture,
        roughness: 0.5,
        metalness: 0.05,
        side: THREE.DoubleSide
    });
    
    const petal = new THREE.Mesh(petalGeometry, petalMaterial);
    petal.scale.set(size, size, size);
    petal.castShadow = true;
    petal.receiveShadow = true;
    petalGroup.add(petal);
    
    // Add petal veins with normal mapping
    const veinColorTexture = textureLoader.load('/textures/common/vein-color.jpg');
    const veinNormalTexture = textureLoader.load('/textures/common/vein-normal.jpg');
    
    for (let i = 0; i < 5; i++) {
        const veinGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.8, 4);
        const veinMaterial = new THREE.MeshStandardMaterial({
            map: veinColorTexture,
            normalMap: veinNormalTexture,
            roughness: 0.7,
            metalness: 0.1
        });
        const vein = new THREE.Mesh(veinGeometry, veinMaterial);
        vein.rotation.z = Math.PI / 2;
        vein.position.y = 0.2 + i * 0.15;
        vein.scale.set(size, size, size);
        petalGroup.add(vein);
    }
    
    return petalGroup;
}

// Helper function to create realistic leaf
function createRealisticLeaf(textureLoader, colorTexture, normalTexture, roughnessTexture) {
    const leafGroup = new THREE.Group();
    
    // Create leaf shape with more detail
    const leafShape = new THREE.Shape();
    leafShape.moveTo(0, 0);
    leafShape.bezierCurveTo(0.2, 0.3, 0.5, 0.8, 0, 1.5);
    leafShape.bezierCurveTo(-0.5, 0.8, -0.2, 0.3, 0, 0);
    
    // Extrude leaf shape with more detail
    const extrudeSettings = {
        depth: 0.02,
        bevelEnabled: true,
        bevelThickness: 0.01,
        bevelSize: 0.01,
        bevelSegments: 3
    };
    
    const leafGeometry = new THREE.ExtrudeGeometry(leafShape, extrudeSettings);
    
    // Apply UV mapping to the leaf
    leafGeometry.computeBoundingBox();
    const max = leafGeometry.boundingBox.max;
    const min = leafGeometry.boundingBox.min;
    const offset = new THREE.Vector2(0 - min.x, 0 - min.y);
    const range = new THREE.Vector2(max.x - min.x, max.y - min.y);
    const faces = leafGeometry.attributes.position.array.length / 3;
    
    const uvs = new Float32Array(faces * 2);
    
    for (let i = 0; i < faces; i++) {
        uvs[i * 2] = (leafGeometry.attributes.position.array[i * 3] + offset.x) / range.x;
        uvs[i * 2 + 1] = (leafGeometry.attributes.position.array[i * 3 + 1] + offset.y) / range.y;
    }
    
    leafGeometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
    
    const leafMaterial = new THREE.MeshStandardMaterial({
        map: colorTexture,
        normalMap: normalTexture,
        roughnessMap: roughnessTexture,
        roughness: 0.6,
        metalness: 0.1,
        side: THREE.DoubleSide
    });
    
    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf.castShadow = true;
    leaf.receiveShadow = true;
    leafGroup.add(leaf);
    
    // Add leaf veins with normal mapping
    const veinColorTexture = textureLoader.load('/textures/common/vein-color.jpg');
    const veinNormalTexture = textureLoader.load('/textures/common/vein-normal.jpg');
    
    for (let i = 0; i < 3; i++) {
        const veinGeometry = new THREE.CylinderGeometry(0.005, 0.005, 1.0, 4);
        const veinMaterial = new THREE.MeshStandardMaterial({
            map: veinColorTexture,
            normalMap: veinNormalTexture,
            roughness: 0.7,
            metalness: 0.1
        });
        const vein = new THREE.Mesh(veinGeometry, veinMaterial);
        vein.rotation.z = Math.PI / 2;
        vein.position.y = 0.3 + i * 0.3;
        leafGroup.add(vein);
    }
    
    return leafGroup;
}

// Helper function to create realistic tree
function createRealisticTree(textureLoader) {
    const treeGroup = new THREE.Group();
    
    // Load tree textures
    const barkColorTexture = textureLoader.load('/textures/tree/bark-color.jpg');
    const barkNormalTexture = textureLoader.load('/textures/tree/bark-normal.jpg');
    const barkRoughnessTexture = textureLoader.load('/textures/tree/bark-roughness.jpg');
    
    const foliageColorTexture = textureLoader.load('/textures/tree/foliage-color.jpg');
    const foliageNormalTexture = textureLoader.load('/textures/tree/foliage-normal.jpg');
    const foliageRoughnessTexture = textureLoader.load('/textures/tree/foliage-roughness.jpg');
    
    // Trunk with realistic bark texture
    const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 4, 16);
    const trunkMaterial = new THREE.MeshStandardMaterial({
        map: barkColorTexture,
        normalMap: barkNormalTexture,
        roughnessMap: barkRoughnessTexture,
        roughness: 0.9,
        metalness: 0.1
    });
    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
    trunk.position.y = 1;
    trunk.castShadow = true;
    treeGroup.add(trunk);
    
    // Foliage with realistic leaves texture
    const foliageGeometry = new THREE.SphereGeometry(2, 16, 16);
    const foliageMaterial = new THREE.MeshStandardMaterial({
        map: foliageColorTexture,
        normalMap: foliageNormalTexture,
        roughnessMap: foliageRoughnessTexture,
        roughness: 0.8,
        metalness: 0.05
    });
    const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
    foliage.position.y = 4;
    foliage.castShadow = true;
    treeGroup.add(foliage);
    
    return treeGroup;
}

// Helper function to create realistic rock
function createRealisticRock(textureLoader) {
    // Load rock textures
    const rockColorTexture = textureLoader.load('/textures/rock/rock-color.jpg');
    const rockNormalTexture = textureLoader.load('/textures/rock/rock-normal.jpg');
    const rockRoughnessTexture = textureLoader.load('/textures/rock/rock-roughness.jpg');
    
    const rockGeometry = new THREE.DodecahedronGeometry(1, 1);
    const rockMaterial = new THREE.MeshStandardMaterial({
        map: rockColorTexture,
        normalMap: rockNormalTexture,
        roughnessMap: rockRoughnessTexture,
        roughness: 0.9,
        metalness: 0.1
    });
    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
    rock.castShadow = true;
    rock.receiveShadow = true;
    
    // Randomize rock shape
    for (let i = 0; i < rockGeometry.attributes.position.count; i++) {
        const x = rockGeometry.attributes.position.getX(i);
        const y = rockGeometry.attributes.position.getY(i);
        const z = rockGeometry.attributes.position.getZ(i);
        
        rockGeometry.attributes.position.setXYZ(
            i,
            x * (0.8 + Math.random() * 0.4),
            y * (0.8 + Math.random() * 0.4),
            z * (0.8 + Math.random() * 0.4)
        );
    }
    rockGeometry.computeVertexNormals();
    
    return rock;
}

// Helper function to create realistic water droplet
function createRealisticWaterDroplet() {
    const dropletGeometry = new THREE.SphereGeometry(0.05, 16, 16);
    const dropletMaterial = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        metalness: 0.0,
        roughness: 0.0,
        transmission: 0.9,
        transparent: true,
        opacity: 0.8,
        ior: 1.33,
        thickness: 0.5,
        clearcoat: 1.0,
        clearcoatRoughness: 0.1
    });
    const droplet = new THREE.Mesh(dropletGeometry, dropletMaterial);
    droplet.scale.set(1, 0.7, 1);
    return droplet;
}

// Helper function to create post-processing effects
function createPostProcessing(renderer, scene, camera) {
    const composer = new THREE.EffectComposer(renderer);
    
    // Render pass
    const renderPass = new THREE.RenderPass(scene, camera);
    composer.addPass(renderPass);
    
    // Bloom pass
    const bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        0.2, // strength
        0.4, // radius
        0.1  // threshold
    );
    composer.addPass(bloomPass);
    
    // Depth of field pass
    const dofPass = new THREE.BokehPass(scene, camera, {
        focus: 10.0,
        aperture: 0.025,
        maxblur: 0.01,
        width: window.innerWidth,
        height: window.innerHeight
    });
    composer.addPass(dofPass);
    
    // Tone mapping pass
    const toneMappingPass = new THREE.ShaderPass(THREE.ToneMappingShader);
    toneMappingPass.uniforms["exposure"].value = 1.0;
    composer.addPass(toneMappingPass);
    
    // Anti-aliasing pass
    const fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
    const pixelRatio = renderer.getPixelRatio();
    fxaaPass.material.uniforms['resolution'].value.x = 1 / (container.clientWidth * pixelRatio);
    fxaaPass.material.uniforms['resolution'].value.y = 1 / (container.clientHeight * pixelRatio);
    composer.addPass(fxaaPass);
    
    // Output pass
    const outputPass = new THREE.ShaderPass(THREE.CopyShader);
    outputPass.renderToScreen = true;
    composer.addPass(outputPass);
    
    return composer;
}

// Helper function to animate professional flower
function animateProfessionalFlower(flowerGroup, time, windStrength) {
    // Gentle swaying in wind
    flowerGroup.rotation.z = Math.sin(time * 0.5) * 0.05 * windStrength;
    flowerGroup.rotation.x = Math.cos(time * 0.3) * 0.03 * windStrength;
    
    // Animate petals
    const petalGroup = flowerGroup.children[1]; // Assuming petal group is second child
    if (petalGroup) {
        petalGroup.children.forEach((petal, i) => {
            petal.rotation.z += Math.sin(time + i) * 0.001 * windStrength;
        });
    }
    
    // Animate center
    const centerGroup = flowerGroup.children[2]; // Assuming center group is third child
    if (centerGroup) {
        centerGroup.rotation.y += 0.002;
        
        // Animate pollen
        centerGroup.children.forEach((pollen, i) => {
            if (i > 0) { // Skip main center
                pollen.scale.setScalar(1 + Math.sin(time * 2 + i) * 0.05);
            }
        });
    }
}

// Helper function to update professional flower
function updateProfessionalFlower(flowerGroup, textures) {
    // Load new textures
    const textureLoader = new THREE.TextureLoader();
    
    const stemColorTexture = textureLoader.load(textures.stemColor);
    const stemNormalTexture = textureLoader.load(textures.stemNormal);
    
    const leafColorTexture = textureLoader.load(textures.leafColor);
    const leafNormalTexture = textureLoader.load(textures.leafNormal);
    
    const petalColorTexture = textureLoader.load(textures.petalColor);
    const petalNormalTexture = textureLoader.load(textures.petalNormal);
    const petalRoughnessTexture = textureLoader.load(textures.petalRoughness);
    
    const centerColorTexture = textureLoader.load(textures.centerColor);
    const centerNormalTexture = textureLoader.load(textures.centerNormal);
    
    // Update stem
    const stem = flowerGroup.children[0];
    if (stem && stem.material) {
        stem.material.map = stemColorTexture;
        stem.material.normalMap = stemNormalTexture;
        stem.material.needsUpdate = true;
    }
    
    // Update leaves
    const leafStartIndex = 1; // Assuming leaves start after stem
    for (let i = 0; i < 5; i++) {
        const leaf = flowerGroup.children[leafStartIndex + i];
        if (leaf && leaf.children[0] && leaf.children[0].material) {
            leaf.children[0].material.map = leafColorTexture;
            leaf.children[0].material.normalMap = leafNormalTexture;
            leaf.children[0].material.needsUpdate = true;
        }
    }
    
    // Update petals
    const petalGroup = flowerGroup.children[leafStartIndex + 5]; // Assuming petal group is after leaves
    if (petalGroup) {
        petalGroup.children.forEach(petal => {
            if (petal.children[0] && petal.children[0].material) {
                petal.children[0].material.map = petalColorTexture;
                petal.children[0].material.normalMap = petalNormalTexture;
                petal.children[0].material.roughnessMap = petalRoughnessTexture;
                petal.children[0].material.needsUpdate = true;
            }
        });
    }
    
    // Update center
    const centerGroup = flowerGroup.children[leafStartIndex + 6]; // Assuming center group is after petals
    if (centerGroup && centerGroup.children[0] && centerGroup.children[0].material) {
        centerGroup.children[0].material.map = centerColorTexture;
        centerGroup.children[0].material.normalMap = centerNormalTexture;
        centerGroup.children[0].material.needsUpdate = true;
    }
}

// Helper function to update professional environment
function updateProfessionalEnvironment(scene, species) {
    // Update environment based on species
    const environmentConfig = {
        'rose': {
            hdri: '/textures/environment/rose-garden-hdri.jpg',
            groundColor: '/textures/ground/rose-garden-color.jpg',
            groundNormal: '/textures/ground/rose-garden-normal.jpg'
        },
        'tulip': {
            hdri: '/textures/environment/tulip-field-hdri.jpg',
            groundColor: '/textures/ground/tulip-field-color.jpg',
            groundNormal: '/textures/ground/tulip-field-normal.jpg'
        },
        'orchid': {
            hdri: '/textures/environment/orchid-greenhouse-hdri.jpg',
            groundColor: '/textures/ground/greenhouse-floor-color.jpg',
            groundNormal: '/textures/ground/greenhouse-floor-normal.jpg'
        },
        'sunflower': {
            hdri: '/textures/environment/sunflower-field-hdri.jpg',
            groundColor: '/textures/ground/sunflower-field-color.jpg',
            groundNormal: '/textures/ground/sunflower-field-normal.jpg'
        }
    };
    
    const config = environmentConfig[species] || environmentConfig['rose'];
    
    // Update HDRI
    const textureLoader = new THREE.TextureLoader();
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();
    
    textureLoader.load(
        config.hdri,
        (texture) => {
            const envMap = pmremGenerator.fromEquirectangular(texture).texture;
            scene.environment = envMap;
            scene.background = envMap;
            texture.dispose();
            pmremGenerator.dispose();
        }
    );
    
    // Update ground
    scene.children.forEach(child => {
        if (child.material && child.material.map && child.geometry instanceof THREE.PlaneGeometry) {
            textureLoader.load(
                config.groundColor,
                (texture) => {
                    child.material.map = texture;
                    child.material.needsUpdate = true;
                }
            );
            
            textureLoader.load(
                config.groundNormal,
                (texture) => {
                    child.material.normalMap = texture;
                    child.material.needsUpdate = true;
                }
            );
        }
    });
}

// Helper function to update professional lighting
function updateProfessionalLighting(scene, timeOfDay) {
    const timeConfig = {
        'dawn': {
            ambientIntensity: 0.3,
            ambientColor: 0xffd4a3,
            directionalIntensity: 0.6,
            directionalColor: 0xffa366,
            rimIntensity: 0.2,
            rimColor: 0xff9e80
        },
        'day': {
            ambientIntensity: 0.5,
            ambientColor: 0xffffff,
            directionalIntensity: 0.8,
            directionalColor: 0xffffff,
            rimIntensity: 0.3,
            rimColor: 0x8bb7ff
        },
        'dusk': {
            ambientIntensity: 0.3,
            ambientColor: 0xd4a3ff,
            directionalIntensity: 0.6,
            directionalColor: 0xa366ff,
            rimIntensity: 0.2,
            rimColor: 0x9e80ff
        },
        'night': {
            ambientIntensity: 0.1,
            ambientColor: 0x8899aa,
            directionalIntensity: 0.2,
            directionalColor: 0xaabbff,
            rimIntensity: 0.1,
            rimColor: 0x6688ff
        }
    };
    
    const config = timeConfig[timeOfDay] || timeConfig['day'];
    
    // Update lights
    scene.children.forEach(child => {
        if (child instanceof THREE.AmbientLight) {
            child.intensity = config.ambientIntensity;
            child.color.setHex(config.ambientColor);
        }
        if (child instanceof THREE.DirectionalLight && child.position.y > 5) {
            child.intensity = config.directionalIntensity;
            child.color.setHex(config.directionalColor);
        }
        if (child instanceof THREE.DirectionalLight && child.position.y < 5) {
            child.intensity = config.rimIntensity;
            child.color.setHex(config.rimColor);
        }
    });
}

// Helper function to update professional season
function updateProfessionalSeason(scene, season) {
    const seasonConfig = {
        'spring': {
            groundColor: '/textures/ground/spring-grass-color.jpg',
            groundNormal: '/textures/ground/spring-grass-normal.jpg',
            treeFoliage: '/textures/tree/spring-foliage-color.jpg'
        },
        'summer': {
            groundColor: '/textures/ground/summer-grass-color.jpg',
            groundNormal: '/textures/ground/summer-grass-normal.jpg',
            treeFoliage: '/textures/tree/summer-foliage-color.jpg'
        },
        'autumn': {
            groundColor: '/textures/ground/autumn-grass-color.jpg',
            groundNormal: '/textures/ground/autumn-grass-normal.jpg',
            treeFoliage: '/textures/tree/autumn-foliage-color.jpg'
        },
        'winter': {
            groundColor: '/textures/ground/winter-snow-color.jpg',
            groundNormal: '/textures/ground/winter-snow-normal.jpg',
            treeFoliage: '/textures/tree/winter-bare-color.jpg'
        }
    };
    
    const config = seasonConfig[season] || seasonConfig['summer'];
    
    const textureLoader = new THREE.TextureLoader();
    
    // Update ground
    scene.children.forEach(child => {
        if (child.material && child.material.map && child.geometry instanceof THREE.PlaneGeometry) {
            textureLoader.load(
                config.groundColor,
                (texture) => {
                    child.material.map = texture;
                    child.material.needsUpdate = true;
                }
            );
            
            textureLoader.load(
                config.groundNormal,
                (texture) => {
                    child.material.normalMap = texture;
                    child.material.needsUpdate = true;
                }
            );
        }
    });
    
    // Update trees
    scene.children.forEach(child => {
        if (child.children && child.children[1] && child.children[1].material) {
            textureLoader.load(
                config.treeFoliage,
                (texture) => {
                    child.children[1].material.map = texture;
                    child.children[1].material.needsUpdate = true;
                }
            );
        }
    });
}

// Helper function to update camera preset
function updateCameraPreset(camera, preset) {
    const presetConfig = {
        'closeup': {
            position: { x: 0, y: 2, z: 5 },
            target: { x: 0, y: 1, z: 0 }
        },
        'medium': {
            position: { x: 0, y: 3, z: 10 },
            target: { x: 0, y: 1, z: 0 }
        },
        'wide': {
            position: { x: 0, y: 5, z: 15 },
            target: { x: 0, y: 1, z: 0 }
        },
        'top': {
            position: { x: 0, y: 10, z: 0 },
            target: { x: 0, y: 0, z: 0 }
        }
    };
    
    const config = presetConfig[preset] || presetConfig['medium'];
    
    // Animate camera to new position
    const startPosition = camera.position.clone();
    const startTarget = new THREE.Vector3(0, 1, 0);
    const endPosition = new THREE.Vector3(config.position.x, config.position.y, config.position.z);
    const endTarget = new THREE.Vector3(config.target.x, config.target.y, config.target.z);
    
    const duration = 1000; // ms
    const startTime = Date.now();
    
    function animateCamera() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Ease in-out function
        const easedProgress = progress < 0.5 
            ? 2 * progress * progress 
            : 1 - Math.pow(-2 * progress + 2, 2) / 2;
        
        camera.position.lerpVectors(startPosition, endPosition, easedProgress);
        camera.lookAt(startTarget.clone().lerp(endTarget, easedProgress));
        
        if (progress < 1) {
            requestAnimationFrame(animateCamera);
        }
    }
    
    animateCamera();
}         
            
            



            
            
            function initPredictionMap() {
    if (state.components.predictionMap) return;
    
    const container = document.getElementById('prediction-map-container');
    if (!container) return;
    
    try {
        document.getElementById('prediction-map-loading').style.display = 'none';
        
        // Create a simple Leaflet map
        const map = L.map(container.id).setView([20, 0], 2);
        
        // Add dark tile layer
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 19
        }).addTo(map);
        
        // Create prediction data
        const predictionData = [];
        
        // Generate random prediction points
        for (let i = 0; i < 100; i++) {
            const lat = Math.random() * 180 - 90;
            const lng = Math.random() * 360 - 180;
            const intensity = Math.random();
            
            predictionData.push([lat, lng, intensity]);
        }
        
        // Create heatmap
        const heat = L.heatLayer(predictionData, {
            radius: 25,
            blur: 15,
            maxZoom: 17,
            max: 1.0,
            gradient: {
                0.0: 'blue',
                0.5: 'yellow',
                1.0: 'red'
            }
        }).addTo(map);
        
        // Store reference
        state.predictionMap = {
            map, heat,
            cleanup: () => {
                map.remove();
            }
        };
        
        state.components.predictionMap = true;
    } catch (error) {
        console.error('Error initializing prediction map:', error);
        document.getElementById('prediction-map-loading').innerHTML = '<div class="text-center p-4">Error loading prediction map. Please refresh the page.</div>';
    }
}

// Auto-initialize when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initPredictionMap);
} else {
    // DOM already loaded, run immediately
    initPredictionMap();
}
            function animateStats() {
                try {
                    const countUpOptions = {
                        duration: 3,
                        enableSmoothing: true,
                        separator: ','
                    };
                    
                    new countUp.CountUp('regions-count', 142, countUpOptions).start();
                    new countUp.CountUp('species-count', 4267, countUpOptions).start();
                    new countUp.CountUp('citizen-count', 31428, countUpOptions).start();
                    new countUp.CountUp('satellite-count', 186542, countUpOptions).start();
                    
                    new countUp.CountUp('crop-reduction', 7, { ...countUpOptions, suffix: '%' }).start();
                    new countUp.CountUp('research-institutions', 12, countUpOptions).start();
                    new countUp.CountUp('ai-accuracy', 92, { ...countUpOptions, suffix: '%' }).start();
                    new countUp.CountUp('pollinator-protection', 40, { ...countUpOptions, suffix: '%' }).start();
                    
                    // Animate progress bars
                    setTimeout(() => {
                        document.getElementById('regions-progress').style.width = '92%';
                        document.getElementById('species-progress').style.width = '72%';
                        document.getElementById('citizen-progress').style.width = '95%';
                        document.getElementById('satellite-progress').style.width = '85%';
                    }, 500);
                } catch (error) {
                    console.error('Error animating statistics:', error);
                }
            }
            
            function showToast(message, type = 'info') {
                try {
                    const toastContainer = document.querySelector('.toast-container');
                    const toastId = 'toast-' + Date.now();
                    
                    const iconMap = {
                        'success': 'check-circle text-success',
                        'error': 'exclamation-circle text-danger',
                        'warning': 'exclamation-triangle text-warning',
                        'info': 'info-circle text-info'
                    };
                    
                    const toastHTML = `
                        <div id="${toastId}" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
                            <div class="toast-header">
                                <i class="fas fa-${iconMap[type]} me-2"></i>
                                <strong class="me-auto">BloomWatch Pro</strong>
                                <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
                            </div>
                            <div class="toast-body">
                                ${sanitizeHTML(message)}
                            </div>
                        </div>
                    `;
                    
                    toastContainer.insertAdjacentHTML('beforeend', toastHTML);
                    
                    const toastElement = document.getElementById(toastId);
                    const toast = new bootstrap.Toast(toastElement);
                    toast.show();
                    
                    toastElement.addEventListener('hidden.bs.toast', () => {
                        toastElement.remove();
                    });
                } catch (error) {
                    console.error('Error showing toast:', error);
                    alert(message); // Fallback to alert
                }
            }
            
            function sanitizeHTML(str) {
                const temp = document.createElement('div');
                temp.textContent = str;
                return temp.innerHTML;
            }
            
            function debounce(func, wait) {
                let timeout;
                return function(...args) {
                    const context = this;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(context, args), wait);
                };
            }
            
            function setupIntersectionObservers() {
                const observerOptions = {
                    root: null,
                    rootMargin: '0px',
                    threshold: 0.1
                };
                
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const id = entry.target.id;
                            
                            if (id === 'earth-section' && !state.components.earth) {
                                initAdvancedEarth();
                            } else if (id === 'map-section' && !state.components.map) {
                                initMap();
                            } else if (id === 'data' && !state.components.statsAnimated) {
                                animateStats();
                                state.components.statsAnimated = true;
                            }
                        }
                    });
                }, observerOptions);
                
                // Observe sections
                const sections = ['earth-section', 'map-section', 'data'];
                sections.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        observer.observe(element);
                        state.observers.push({ element, observer });
                    }
                });
                
                return observer;
            }
            
            function setupTabEventListeners() {
                // Initialize charts when tabs are shown
                document.getElementById('temp-flowering-tab')?.addEventListener('shown.bs.tab', () => {
                    if (!state.components.charts.tempFlowering) {
                        setTimeout(() => initCharts(), 100);
                    }
                });
                
                document.getElementById('historical-trends-tab')?.addEventListener('shown.bs.tab', () => {
                    if (!state.components.charts.historical) {
                        setTimeout(() => initCharts(), 100);
                    }
                });
                
                document.getElementById('climate-impact-tab')?.addEventListener('shown.bs.tab', () => {
                    if (!state.components.charts.climate) {
                        setTimeout(() => initCharts(), 100);
                    }
                });
                
                document.getElementById('seasonal-tab')?.addEventListener('shown.bs.tab', () => {
                    if (!state.components.charts.seasonal) {
                        setTimeout(() => initCharts(), 100);
                    }
                });
                
                document.getElementById('species-distribution-tab')?.addEventListener('shown.bs.tab', () => {
                    if (!state.components.charts.species3d) {
                        setTimeout(() => init3DSpeciesChart(), 100);
                    }
                });
                
                document.getElementById('3d-model-tab')?.addEventListener('shown.bs.tab', () => {
                    if (!state.components.species3dModel) {
                        setTimeout(() => init3DSpeciesModel(), 100);
                    }
                });
                
                document.getElementById('prediction-map-tab')?.addEventListener('shown.bs.tab', () => {
                    if (!state.components.predictionMap) {
                        setTimeout(() => initPredictionMap(), 100);
                    }
                });
            }
            
            // Google Gemini API Integration with Mock Fallback
            async function analyzeImageWithGemini(imageFile) {
                if (config.USE_MOCK_GEMINI) {
                    // Mock response for demonstration
                    return new Promise((resolve) => {
                        setTimeout(() => {
                            const mockResults = {
                                species: getRandomSpecies(),
                                confidence: Math.floor(Math.random() * 15) + 85, // 85-99%
                                floweringStage: getRandomFloweringStage(),
                                health: getRandomHealthStatus()
                            };
                            resolve(mockResults);
                        }, 1500);
                    });
                }
                
                // Real Gemini API implementation (would require actual API key)
                try {
                    // Convert image to base64
                    const base64Image = await fileToBase64(imageFile);
                    
                    // Prepare API request
                    const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-pro-vision:generateContent?key=' + config.GEMINI_API_KEY, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts: [
                                    { text: "Analyze this plant image and identify the species, flowering stage, and health status. Return a JSON object with species, confidence (0-100), floweringStage (buds, early, peak, late, finished), and health (poor, fair, good, excellent)." },
                                    {
                                        inline_data: {
                                            mime_type: imageFile.type,
                                            data: base64Image.split(',')[1]
                                        }
                                    }
                                ]
                            }]
                        })
                    });
                    
                    const data = await response.json();
                    
                    // Extract and parse the response
                    if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                        const text = data.candidates[0].content.parts[0].text;
                        try {
                            // Try to parse JSON from the response
                            const jsonMatch = text.match(/\{[^}]+\}/);
                            if (jsonMatch) {
                                return JSON.parse(jsonMatch);
                            }
                        } catch (e) {
                            console.error('Error parsing Gemini response:', e);
                        }
                    }
                    
                    // Fallback to mock if parsing fails
                    return {
                        species: "Unknown species",
                        confidence: 75,
                        floweringStage: "peak",
                        health: "good"
                    };
                } catch (error) {
                    console.error('Error calling Gemini API:', error);
                    showToast('Error analyzing image with AI. Using fallback analysis.', 'warning');
                    
                    // Fallback to mock response
                    return {
                        species: "Unknown species",
                        confidence: 70,
                        floweringStage: "peak",
                        health: "fair"
                    };
                }
            }
            
            // Helper function to convert file to base64
            function fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });
            }
            
            // Helper functions for mock data
            function getRandomSpecies() {
                const species = [
                    "Rosa rubiginosa", "Tulipa gesneriana", "Orchis mascula", "Helianthus annuus",
                    "Prunus serrulata", "Narcissus pseudonarcissus", "Iris germanica", "Lilium candidum",
                    "Dianthus caryophyllus", "Ranunculus asiaticus", "Papaver somniferum", "Crocus sativus"
                ];
                return species[Math.floor(Math.random() * species.length)];
            }
            
            function getRandomFloweringStage() {
                const stages = ["buds", "early", "peak", "late", "finished"];
                return stages[Math.floor(Math.random() * stages.length)];
            }
            
            function getRandomHealthStatus() {
                const health = ["poor", "fair", "good", "excellent"];
                return health[Math.floor(Math.random() * health.length)];
            }
            
            function setupFormEventListeners() {
                const form = document.getElementById('contributionForm');
                if (!form) return;
                
                form.addEventListener('submit', async function(e) {
                    e.preventDefault();
                    
                    const submitBtn = document.getElementById('submit-btn');
                    const errorDiv = document.getElementById('form-error');
                    const successDiv = document.getElementById('form-success');
                    
                    errorDiv.style.display = 'none';
                    successDiv.style.display = 'none';
                    
                    if (!form.checkValidity()) {
                        e.stopPropagation();
                        form.classList.add('was-validated');
                        showToast('Please fill in all required fields', 'warning');
                        return;
                    }
                    
                    submitBtn.disabled = true;
                    
                    try {
                        showToast('📤 Submitting your observation...', 'info');
                        
                        // Simulate API call
                        await new Promise(resolve => setTimeout(resolve, 1500));
                        
                        // Update citizen count
                        const citizenCount = document.getElementById('citizen-count');
                        if (citizenCount) {
                            const currentCount = parseInt(citizenCount.textContent.replace(',', ''));
                            citizenCount.textContent = (currentCount + 1).toLocaleString();
                        }
                        
                        successDiv.textContent = '✅ Thank you! Your observation has been submitted successfully.';
                        successDiv.style.display = 'block';
                        showToast('✅ Observation submitted successfully!', 'success');
                        
                        form.reset();
                        form.classList.remove('was-validated');
                        document.getElementById('ai-analysis-result').classList.add('d-none');
                        
                    } catch (error) {
                        console.error('Form submission error:', error);
                        errorDiv.textContent = '❌ Failed to submit. Please try again.';
                        errorDiv.style.display = 'block';
                        showToast('❌ Submission failed', 'error');
                    } finally {
                        submitBtn.disabled = false;
                    }
                });
                
                // Image upload with AI analysis using Google Gemini
                const imageUpload = document.getElementById('image-upload');
                if (imageUpload) {
                    imageUpload.addEventListener('change', async function(e) {
                        if (e.target.files && e.target.files[0]) {
                            const aiResultDiv = document.getElementById('ai-analysis-result');
                            const aiResultContent = document.getElementById('ai-result-content');
                            
                            try {
                                showToast('🤖 Analyzing image with Google Gemini...', 'info');
                                
                                // Use Gemini API with mock fallback
                                const mockResults = await analyzeImageWithGemini(e.target.files[0]);
                                
                                aiResultContent.innerHTML = `
                                    <p><strong>Species:</strong> ${mockResults.species}</p>
                                    <p><strong>Confidence:</strong> ${mockResults.confidence}%</p>
                                    <p><strong>Flowering Stage:</strong> ${mockResults.floweringStage}</p>
                                    <p><strong>Health:</strong> ${mockResults.health}</p>
                                `;
                                
                                aiResultDiv.classList.remove('d-none');
                                
                                // Pre-fill form
                                document.getElementById('species').value = mockResults.species;
                                document.getElementById('flowering-stage').value = mockResults.floweringStage;
                                
                                showToast('✅ AI analysis complete!', 'success');
                            } catch (error) {
                                console.error('AI analysis error:', error);
                                showToast('❌ AI analysis failed', 'error');
                            }
                        }
                    });
                }
            }
            
            function setupScrollEventListeners() {
                // Update active navigation on scroll with debouncing
                const updateActiveNav = debounce(() => {
                    const sections = document.querySelectorAll('section[id]');
                    const scrollY = window.pageYOffset;
                    
                    sections.forEach(section => {
                        const sectionHeight = section.offsetHeight;
                        const sectionTop = section.offsetTop - 100;
                        const sectionId = section.getAttribute('id');
                        
                        if (scrollY > sectionTop && scrollY <= sectionTop + sectionHeight) {
                            document.querySelectorAll('.nav-link').forEach(link => {
                                link.classList.remove('active');
                                if (link.getAttribute('href') === `#${sectionId}`) {
                                    link.classList.add('active');
                                }
                            });
                        }
                    });
                }, 100);
                
                window.addEventListener('scroll', updateActiveNav);
            }
            
            function setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        if (config.DEMO_MODE) {
                            endProDemo();
                        }
                        if (document.getElementById('tour-modal').style.display === 'block') {
                            closeTour();
                        }
                    }
                    
                    if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
                        e.preventDefault();
                        startProDemo();
                    }
                    
                    if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
                        e.preventDefault();
                        toggleProMode();
                    }
                    
                    if ((e.ctrlKey || e.metaKey) && e.key === 't') {
                        e.preventDefault();
                        showTour();
                    }
                });
            }
            
            function setupResizeEventListeners() {
                const handleResize = debounce(() => {
                    if (state.earth && state.earth.renderer) {
                        const container = document.getElementById('earth-container');
                        if (container) {
                            const { camera, renderer } = state.earth;
                            camera.aspect = container.clientWidth / container.clientHeight;
                            camera.updateProjectionMatrix();
                            renderer.setSize(container.clientWidth, container.clientHeight);
                        }
                    }
                    
                    if (state.map) {
                        state.map.invalidateSize();
                    }
                }, 250);
                
                window.addEventListener('resize', handleResize);
            }
            
            // Tour functions
            function showTour() {
                document.getElementById('tour-modal').style.display = 'block';
            }
            
            function closeTour() {
                document.getElementById('tour-modal').style.display = 'none';
                localStorage.setItem('tourShown', 'true');
            }
            
            function startExploring() {
                closeTour();
                scrollToSection('data');
            }
            
            // Pro demo functions
            function startProDemo() {
                config.DEMO_MODE = true;
                document.getElementById('demo-mode').style.display = 'block';
                document.getElementById('control-panel').classList.add('show');
                
                showToast('🚀 Starting Automation', 'success');
                
                // Start automatic data updates
                state.demoInterval = setInterval(() => {
                    simulateRealTimeData();
                }, 3000);
                
                // Highlight features
                document.querySelectorAll('.data-card, .impact-metric').forEach(card => {
                    card.classList.add('demo-highlight');
                });
                
                // Auto-scroll through sections
                const sections = ['earth-section', 'data', 'map-section', '#data-sources', 'visualizations', 'predictions', '#contribute'];
                let currentIndex = 0;
                
                const scrollInterval = setInterval(() => {
                    if (currentIndex < sections.length) {
                        scrollToSection(sections[currentIndex]);
                        currentIndex++;
                    } else {
                        clearInterval(scrollInterval);
                        endProDemo();
                    }
                }, 5000);
            }
            
            function endProDemo() {
                config.DEMO_MODE = false;
                document.getElementById('demo-mode').style.display = 'none';
                
                if (state.demoInterval) {
                    clearInterval(state.demoInterval);
                    state.demoInterval = null;
                }
                
                document.querySelectorAll('.demo-highlight').forEach(element => {
                    element.classList.remove('demo-highlight');
                });
                
                showToast('✨ Pro Demo Completed!', 'success');
            }
            
            function toggleProMode() {
                config.PRO_MODE = !config.PRO_MODE;
                if (config.PRO_MODE) {
                    document.body.classList.add('pro-mode');
                    showToast('Automation started', 'success');
                    activateParticleEffects();
                } else {
                    document.body.classList.remove('pro-mode');
                    showToast('Automation ended', 'info');
                }
            }
            
            function showAllMetrics() {
                scrollToSection('data');
                document.querySelectorAll('.impact-metric').forEach(metric => {
                    metric.classList.add('demo-highlight');
                });
                
                setTimeout(() => {
                    document.querySelectorAll('.impact-metric').forEach(metric => {
                        metric.classList.remove('demo-highlight');
                    });
                }, 3000);
            }
            
            function simulateRealTimeData() {
                try {
                    // Update random statistics
                    const stats = ['regions-count', 'species-count', 'citizen-count', 'satellite-count'];
                    const randomStat = stats[Math.floor(Math.random() * stats.length)];
                    const element = document.getElementById(randomStat);
                    
                    if (element) {
                        const currentValue = parseInt(element.textContent.replace(',', ''));
                        const increment = Math.floor(Math.random() * 10) + 1;
                        element.textContent = (currentValue + increment).toLocaleString();
                    }
                    
                    // Add new markers to map
                    if (state.map && state.map.markerClusterGroup && Math.random() > 0.5) {
                        const lat = Math.random() * 180 - 90;
                        const lng = Math.random() * 360 - 180;
                        const stages = ['buds', 'early', 'peak', 'late', 'finished'];
                        const stage = stages[Math.floor(Math.random() * stages.length)];
                        const species = ['Rose', 'Tulip', 'Daisy', 'Sunflower', 'Orchid'][Math.floor(Math.random() * 5)];
                        const sources = ['USA-NPN', 'GLOBE Observer', 'GBIF', 'iNaturalist'][Math.floor(Math.random() * 4)];
                        
                        const color = getStageColor(stage);
                        const marker = L.circleMarker([lat, lng], {
                            radius: 10,
                            fillColor: color,
                            color: '#fff',
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.8
                        });
                        
                        marker.bindPopup(`
                            <div style="text-align: center;">
                                <h4>New Observation</h4>
                                <p><strong>Species:</strong> ${species}</p>
                                <p><strong>Stage:</strong> ${stage}</p>
                                <p><strong>Source:</strong> ${sources}</p>
                            </div>
                        `);
                        
                        state.map.markerClusterGroup.addLayer(marker);
                    }
                } catch (error) {
                    console.error('Error simulating real-time data:', error);
                }
            }
            
            function activateParticleEffects() {
                try {
                    // Destroy existing particles if they exist
                    if (state.particlesInstance) {
                        state.particlesInstance.pJS.fn.vendors.destroypJS();
                        state.particlesInstance = null;
                    }
                    
                    // Reinitialize particles
                    initParticles();
                } catch (error) {
                    console.error('Error activating particle effects:', error);
                }
            }
            
            // Earth control functions
            function toggleEarthRotation() {
                if (state.earth) {
                    state.earth.toggleRotation();
                    showToast(state.earth.earthRotating ? 'Earth rotation enabled' : 'Earth rotation disabled', 'info');
                } else {
                    showToast('3D Earth not loaded yet', 'warning');
                }
            }
            
            function toggleAtmosphere() {
                if (state.earth) {
                    state.earth.toggleAtmosphere();
                    showToast('Atmosphere toggled', 'info');
                } else {
                    showToast('3D Earth not loaded yet', 'warning');
                }
            }
            
            function toggleDataLayers() {
                if (state.earth) {
                    state.earth.toggleDataPoints();
                    showToast('Data layers toggled', 'info');
                } else {
                    showToast('3D Earth not loaded yet', 'warning');
                }
            }
            
            // Map control functions
            function toggleHeatmap() {
                try {
                    if (!state.map) {
                        showToast('Map not loaded yet', 'warning');
                        return;
                    }
                    
                    if (state.heatmap) {
                        state.map.removeLayer(state.heatmap);
                        state.heatmap = null;
                        showToast('Heatmap disabled', 'info');
                    } else {
                        // Create sample heatmap data
                        const heatData = [];
                        for (let i = 0; i < 100; i++) {
                            heatData.push([
                                Math.random() * 180 - 90,
                                Math.random() * 360 - 180,
                                Math.random()
                            ]);
                        }
                        
                        state.heatmap = L.heatLayer(heatData, {
                            radius: 25,
                            blur: 15,
                            maxZoom: 17
                        }).addTo(state.map);
                        
                        showToast('Heatmap enabled', 'info');
                    }
                } catch (error) {
                    console.error('Error toggling heatmap:', error);
                    showToast('Error toggling heatmap', 'error');
                }
            }
            
            function toggleClustering() {
                if (state.map && state.map.markerClusterGroup) {
                    if (state.map.hasLayer(state.map.markerClusterGroup)) {
                        state.map.removeLayer(state.map.markerClusterGroup);
                        showToast('Marker clustering disabled', 'info');
                    } else {
                        state.map.addLayer(state.map.markerClusterGroup);
                        showToast('Marker clustering enabled', 'info');
                    }
                } else {
                    showToast('Map not loaded yet', 'warning');
                }
            }
            
            // Data loading functions
            function loadRealTimeData() {
                showToast('🛰️ Loading NASA real-time data...', 'info');
                setTimeout(() => {
                    simulateRealTimeData();
                    showToast('✅ Real-time data loaded successfully!', 'success');
                }, 2000);
            }
            
            function loadFlowerData() {
                showToast('🌸 Loading latest flower observations...', 'info');
                setTimeout(() => {
                    simulateRealTimeData();
                    showToast('✅ Flower data updated!', 'success');
                }, 1500);
            }
            
            function loadLatestSatelliteImages() {
    // JSON set of 15 different satellite images
    const satelliteImages = [
        "/hac/images/first-img.png",
        "https://example.com/satellite2.jpg",
        "https://example.com/satellite3.jpg",
        "https://example.com/satellite4.jpg",
        "https://example.com/satellite5.jpg",
        "https://example.com/satellite6.jpg",
        "https://example.com/satellite7.jpg",
        "https://example.com/satellite8.jpg",
        "https://example.com/satellite9.jpg",
        "https://example.com/satellite10.jpg",
        "https://example.com/satellite11.jpg",
        "https://example.com/satellite12.jpg",
        "https://example.com/satellite13.jpg",
        "https://example.com/satellite14.jpg",
        "https://example.com/satellite15.jpg"
    ];
    
    showToast('📡 Loading latest satellite imagery...', 'info');
    setTimeout(() => {
        // Update satellite images with random images from the JSON set
        const images = document.querySelectorAll('#satellite-gallery img');
        images.forEach((img, index) => {
            // Set initial random image
            const randomIndex = Math.floor(Math.random() * satelliteImages.length);
            img.src = satelliteImages[randomIndex];
            img.dataset.currentIndex = randomIndex;
            
            // Add click event listener to change to a random image when clicked
            img.addEventListener('click', function() {
                const newRandomIndex = Math.floor(Math.random() * satelliteImages.length);
                this.src = satelliteImages[newRandomIndex];
                this.dataset.currentIndex = newRandomIndex;
            });
        });
        showToast('✅ Latest satellite images loaded!', 'success');
    }, 2000);
}
            
            // Search and filter functions
            function performSearch() {
                const searchInput = document.getElementById('search-input');
                if (!searchInput) return;
                
                const searchTerm = searchInput.value.trim();
                if (!searchTerm) {
                    showToast('Please enter a search term', 'warning');
                    return;
                }
                
                showToast(`🔍 Searching for "${sanitizeHTML(searchTerm)}"...`, 'info');
                setTimeout(() => {
                    showToast(`Found 42 results for "${sanitizeHTML(searchTerm)}"`, 'success');
                }, 1000);
            }
            
            function toggleFilterPanel() {
                const filterPanel = document.getElementById('filter-panel');
                if (filterPanel) {
                    filterPanel.style.display = filterPanel.style.display === 'none' ? 'block' : 'none';
                }
            }
            
            function applyFilters() {
                showToast('🎯 Applying filters...', 'info');
                setTimeout(() => {
                    showToast('✅ Filters applied successfully!', 'success');
                    toggleFilterPanel();
                }, 1000);
            }
            
            function resetFilters() {
                document.querySelectorAll('.filter-checkbox').forEach(checkbox => {
                    checkbox.checked = true;
                });
                
                const timePeriod = document.getElementById('time-period');
                if (timePeriod) {
                    timePeriod.value = 'all';
                }
                
                showToast('🔄 Filters reset', 'info');
            }
            
            // 3D model functions
            function loadSpeciesModel(species) {
                if (!state.species3dModel) {
                    showToast('3D model viewer not loaded yet', 'warning');
                    return;
                }
                
                state.species3dModel.loadModel(species);
            }
            
            // Utility functions
            function scrollToSection(sectionId) {
                const element = document.getElementById(sectionId);
                if (element) {
                    element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }
            
            // Cleanup function
            function cleanup() {
                // Clear intervals
                if (state.demoInterval) clearInterval(state.demoInterval);
                if (state.dataUpdateInterval) clearInterval(state.dataInterval);
                
                // Cleanup Three.js resources
                if (state.earth && state.earth.cleanup) {
                    state.earth.cleanup();
                }
                
                if (state.charts.species3d && state.charts.species3d.cleanup) {
                    state.charts.species3d.cleanup();
                }
                
                if (state.species3dModel && state.species3dModel.cleanup) {
                    state.species3dModel.cleanup();
                }
                
                if (state.predictionMap && state.predictionMap.cleanup) {
                    state.predictionMap.cleanup();
                }
                
                // Cleanup particles
                if (state.particlesInstance) {
                    state.particlesInstance.pJS.fn.vendors.destroypJS();
                }
                
                // Disconnect observers
                state.observers.forEach(({ element, observer }) => {
                    observer.unobserve(element);
                });
            }
            
            // Public API
            return {
                init: function() {
                    // Initialize all components
                    initParticles();
                    initTypedText();
                    initAOS();
                    
                    // Set up event listeners
                    setupIntersectionObservers();
                    setupTabEventListeners();
                    setupFormEventListeners();
                    setupScrollEventListeners();
                    setupKeyboardShortcuts();
                    setupResizeEventListeners();
                    
                    // Set today's date
                    const observationDate = document.getElementById('observation-date');
                    if (observationDate) {
                        observationDate.valueAsDate = new Date();
                    }
                    
                    // Show control panel after delay
                    setTimeout(() => {
                        document.getElementById('control-panel').classList.add('show');
                    }, 3000);
                    
                    // Show tour for first-time users
                    if (!config.TOUR_SHOWN) {
                        setTimeout(() => {
                            showTour();
                        }, 2000);
                    }
                    
                    // Start real-time data updates
                    state.dataUpdateInterval = setInterval(() => {
                        if (Math.random() > 0.7) {
                            simulateRealTimeData();
                        }
                    }, 10000);
                    
                    // Initialize phenology chart on load
                    setTimeout(() => {
                        initCharts();
                    }, 500);
                    
                    // Cleanup on page unload
                    window.addEventListener('beforeunload', cleanup);
                },
                
                // Public methodss
                scrollToSection,
                performSearch,
                toggleFilterPanel,
                applyFilters,
                resetFilters,
                loadRealTimeData,
                loadFlowerData,
                loadLatestSatelliteImages,
                toggleEarthRotation,
                toggleAtmosphere,
                toggleDataLayers,
                toggleHeatmap,
                toggleClustering,
                loadSpeciesModel,
                startProDemo,
                toggleProMode,
                showAllMetrics,
                simulateRealTimeData,
                activateParticleEffects,
                showTour,
                closeTour,
                startExploring,
                
                // Getters for state
                getConfig: () => ({ ...config }),
                getState: () => ({ ...state })
            };
        })();
        
        // Initialize app when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            app.init();
        });
        
        // Error handling
        window.addEventListener('error', (e) => {
            console.error('Global error:', e.error);
            app.showToast('An error occurred. Please refresh the page.', 'error');
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled promise rejection:', e.reason);
            app.showToast('An error occurred. Please refresh the page.', 'error');
        });
    </script>
</body>
</html>
